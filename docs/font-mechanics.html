<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:x="https://www.texmacs.org/2002/extensions" xmlns:m="http://www.w3.org/1998/Math/MathML">
  <head>
    <title>TeXmacs notes</title>
    <meta charset="utf-8" content="TeXmacs 2.1.4" name="generator"></meta>
    <link href="../resources/notes-base.css" type="text/css" rel="stylesheet"></link>
    <link href="../resources/blog-icon.png" rel="icon"></link>
    <script src="../resources/highlight.pack.js" language="javascript" defer></script>
    <script src="../resources/notes-base.js" language="javascript" defer></script>
  </head>
  <body>
    <div class="toggle" style="display: none">
      <p>
        
      </p>
    </div>
    <div class="notes-header">
      <p>
        <img class="image" src="../resources/texmacs-blog-transparent.png" width="28.116784"></img><span style="margin-left: 2pt"></span><a href="./main.html">[main]</a><em
        class="notes-header-name">Notes on TeXmacs</em>
      </p>
    </div>
    <h1 id="auto-1">Font mechanics<span style="margin-left: 1em"></span></h1>
    <div class="notes-abstract">
      We describe the various mechanisms and features of TeXmacs font
      handling, from the user interface at the level of documents to the inner
      workings of the various fonts types at the level of the <tt class="verbatim">C++</tt>
      source code. TeXmacs implements sophisticate algorithms to allow to use
      a wide variety of fonts despite of the facts that they do to have all
      the necessary glyphs, especially for the typesetting of technical
      documents.
    </div>
    <p>
      [Version 1.0 of 3.1.2025. By <a href="https://github.com/mgubi">@mgubi</a>]
    </p>
    <p>
      This document describes TeXmacs fonts handling. We describe the state of
      affairs as per <tt class="verbatim">svn</tt> revision <tt>r14561</tt> (December
      2024, TeXmacs <tt>2.14+</tt>). Parts of the general overview of fonts in
      TeXmacs are extracted, for reference, from the official documentation
      and from the paper<a href="https://www.texmacs.org/joris/fontart/fontart-abs.html"> &ldquo;Mathematical font art&rdquo;</a> by
      Joris van der Hoeven.
    </p>
    <h2 id="auto-2">1.<span style="margin-left: 1em"></span>Fonts in TeXmacs<span style="margin-left: 1em"></span></h2>
    <p>
      Philosophically speaking, we think that a font should be characterized
      by the following two essential properties:
    </p>
    <ol>
      <li>
        <p>
          A font associates graphical meanings to <i>words</i>. The words can
          always be represented by strings.
        </p>
      </li>
      <li>
        <p>
          The way this association takes place is coherent as a function of
          the word.
        </p>
      </li>
    </ol>
    <p>
      By a word, we either mean a word in a natural language, or a sequence of
      mathematical, technical or artistic symbols. This way of viewing fonts
      has several advantages:
    </p>
    <ol>
      <li>
        <p>
          A font may take care of kerning and ligatures.
        </p>
      </li>
      <li>
        <p>
          A font may consist of several &ldquo;physical fonts&rdquo;, which
          are somehow merged together.
        </p>
      </li>
      <li>
        <p>
          A font might in principle automatically build very complicated
          glyphs like hieroglyphs or large delimiters from words in a well
          chosen encoding.
        </p>
      </li>
      <li>
        <p>
          A font is an irreducible and persistent entity, not a bunch of
          commands whose actions may depend on some environment.
        </p>
      </li>
    </ol>
    <p>
      Notice finally that the &ldquo;graphical meaning&rdquo; of a word might
      be more than just a bitmap: it might also contain some information about
      a logical bounding box, appropriate places for scripts, etc. Similarly,
      the &ldquo;coherence of the association&rdquo; should be interpreted in
      its broadest sense: the font might contain additional information for
      the global typesetting of the words on a page, like the recommended
      distance between lines, the height of a fraction bar, etc.
    </p>
    <p>
      Fonts are usually made up from glyphs like &ldquo;x&rdquo;,
      &ldquo;ffi&rdquo;, &ldquo;<span class="no-breaks"><img src="font-mechanics-1.png" style="margin-left: -0.0103434343434343em; margin-bottom: -2.0202020202021e-5em; margin-right: -0.0827474747474747em; margin-top: -0.0103434343434343em; vertical-align: -0.0103232323232323em; height: 0.47579797979798em"></img>&rdquo;,</span>
      &ldquo;<span class="no-breaks"><img src="font-mechanics-2.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.0351111111111111em; margin-right: -0.0103434343434343em; margin-top: -0.0142424242424243em; vertical-align: -0.245737373737374em; height: 0.956767676767677em"></img>&rdquo;,</span>
      <abbr>etc.</abbr> When rendering a string, the string is decomposed into
      glyphs so as to take into account ligatures (like fi, fl, ff, ffi, ffl).
      Next, the individual glyphs are positioned while taking into account
      kerning information (in &ldquo;xo&rdquo; the &ldquo;o&rdquo; character
      is slightly shifted to the left so as to take profit out of the hole in
      the &ldquo;x&rdquo;). In the case of mathematical fonts, TeXmacs also
      provides a coherent rendering for resizable characters, like the large
      brackets in
    </p>
    <center>
      <img src="font-mechanics-3.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.0284646464646465em; margin-right: -0.0103434343434343em; margin-top: 0em; vertical-align: -0.310848484848485em; height: 1.33739393939394em"></img>
    </center>
    <h2 id="auto-3">2.<span style="margin-left: 1em"></span>String encodings<span style="margin-left: 1em"></span></h2>
    <p>
      All text strings in TeXmacs consist of sequences of either specific or
      universal symbols. A specific symbol is a character, different from <tt
      class="verbatim">'\0'</tt>, <tt class="verbatim">'&lt;'</tt> and <tt class="verbatim">'&gt;'</tt>. Its
      meaning may depend on the particular font which is being used. A
      universal symbol is a string starting with <tt class="verbatim">'&lt;'</tt>,
      followed by an arbitrary sequence of characters different from <tt
      class="verbatim">'\0'</tt>, <tt class="verbatim">'&lt;'</tt> and <tt class="verbatim">'&gt;'</tt>, and
      ending with <tt class="verbatim">'&gt;'</tt>. The meaning of universal characters
      does not depend on the particular font which is used, but different
      fonts may render them in a different way.
    </p>
    <p>
      Universal symbols can also be used to represent mathematical symbols of
      variable sizes like large brackets. The point here is that the shapes of
      such symbols depend on certain size parameters, which can not
      conveniently be thought of as font parameters. This problem is solved by
      letting the extra parameters be part of the symbol. For instance, <tt
      class="verbatim">&quot;&lt;left-(-1&gt;&quot;</tt> would be usual bracket and <tt
      class="verbatim">&quot;&lt;left-(-2&gt;&quot;</tt> a slightly larger one.
    </p>
    <h2 id="auto-4">3.<span style="margin-left: 1em"></span>Specifying the current font<span style="margin-left: 1em"></span></h2>
    <p>
      Font properties may be controlled globally for the whole document in
      <class class="tmweb-menu" style="font-family: sans-serif">Document</class>&rarr;<class class="tmweb-menu" style="font-family: sans-serif">Font</class><a
      id="auto-5"></a> and locally for document fragments in <class class="tmweb-menu" style="font-family: sans-serif">Format</class>&rarr;<class
      class="tmweb-menu" style="font-family: sans-serif">Font</class><a id="auto-6"></a>.
    </p>
    <p>
      A <em>font family</em> is a family of fonts with different
      characteristics (like font weight, slant, <abbr>etc.</abbr>), but with a
      globally consistent rendering. One also says that the fonts in a font
      family &ldquo;mix well together&rdquo;. For instance, the standard roman
      font and its <b>bold</b> and <i>italic</i> variants mix well together,
      but the computer modern roman font and the Avant Garde font do not.
    </p>
    <p style="margin-top: 1em; margin-bottom: 1em">
      <strong>Remark <class style="font-style: normal">1</class>. </strong>In versions of TeXmacs
      prior to 1.99.1, the fonts for the mathematical and programming modes
      could be controlled independently using the environment variables <font
      color="#008000"><i>math-font</i></font>, <font color="#008000"><i>math-font-family</i></font>,
      <font color="#008000"><i>math-font-series</i></font>, <font color="#008000"><i>math-font-shape</i></font>,
      <font color="#008000"><i>prog-font</i></font>, <font color="#008000"><i>prog-font-family</i></font>,
      <font color="#008000"><i>prog-font-series</i></font>, <font color="#008000"><i>prog-font-shape</i></font>.
      In more recent versions of TeXmacs, the environment variables <font
      color="#008000"><i>font</i></font>, <font color="#008000"><i>font-family</i></font>, <font
      color="#008000"><i>font-series</i></font> and <font color="#008000"><i>font-shape</i></font>
      directly control the font for all modes.
    </p>
    <div class="compact-block" style="text-indent: 0em">
      <div class="left-tab" style="margin-top: 0.5em">
        <font color="#008000"><i>font</i></font><span style="margin-left: 0.25em"></span><img src="font-mechanics-4.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434344em; margin-top: -0.0206868686868687em; vertical-align: 0em; height: 0.491313131313131em"></img><span
        style="margin-left: 0.25em"></span><tt>roman</tt>
      </div>
      <div class="right-tab" style="margin-bottom: 0.25em">
        <font color="#707070">(font name)</font>
      </div>
    </div>
    <div style="margin-left: 42.175176192px">
      <p>
        These variables control the main name of the font, also called the
        <em>font family</em>. For instance:
      </p>
    </div>
    <div class="tmweb-code" style="margin-left: 42.175176192px">
      <p>
        <class style="font-family: Times New Roman">Computer modern roman</class>, Linux Libertine,
        Chancery, Palatino
      </p>
    </div>
    <div style="margin-left: 42.175176192px">
      <p>
        Similarly, TeXmacs supports various mathematical fonts: <font color="#800000">[Does
        not render correclty]</font>
      </p>
    </div>
    <div class="tmweb-code" style="margin-left: 42.175176192px">
      <p>
        Roman: <img src="font-mechanics-5.png" style="margin-left: -0.0103434343434343em; margin-bottom: -2.0202020202021e-5em; margin-right: -0.0103434343434339em; margin-top: -0.0155151515151515em; vertical-align: -0.0103232323232323em; height: 0.829191919191919em"></img>
      </p>
      <p>
        Adobe: <img src="font-mechanics-6.png" style="margin-left: -0.0103434343434343em; margin-bottom: -2.0202020202021e-5em; margin-right: -0.0103434343434339em; margin-top: -0.0155151515151515em; vertical-align: -0.0103232323232323em; height: 0.829191919191919em"></img>
      </p>
      <p>
        New roman: <img src="font-mechanics-7.png" style="margin-left: -0.0103434343434343em; margin-bottom: -2.0202020202021e-5em; margin-right: -0.0103434343434339em; margin-top: -0.0155151515151515em; vertical-align: -0.0103232323232323em; height: 0.829191919191919em"></img>
      </p>
      <p>
        Concrete: <img src="font-mechanics-8.png" style="margin-left: -0.0103434343434343em; margin-bottom: -2.0202020202021e-5em; margin-right: -0.0103434343434339em; margin-top: -0.0155151515151515em; vertical-align: -0.0103232323232323em; height: 0.829191919191919em"></img>
      </p>
    </div>
    <div style="margin-bottom: 0.5em; margin-left: 42.175176192px">
      <p>
        Most fonts only implement a subset of all Unicode glyphs. Sometimes,
        the user might wish to combine several fonts to cover a larger subset.
        For instance, when specifying <tt class="verbatim">roman,IPAMincho</tt> or <tt
        class="verbatim">cjk=IPAMincho,roman</tt> as the <font color="#008000"><i>font</i></font>
        name, ordinary text and mathematics will be typeset using the default
        <tt class="verbatim">roman</tt> font, whereas Chinese text will use the <tt
        class="verbatim">IPAMincho</tt> font. Similarly, when specifying <tt class="verbatim">math=Stix,roman</tt>
        as the <font color="#008000"><i>font</i></font> name, ordinary text will be
        typeset using the default <tt class="verbatim">roman</tt> font, but mathematical
        formulas using the <tt class="verbatim">Stix</tt> font.
      </p>
    </div>
    <div class="compact-block" style="text-indent: 0em">
      <div class="left-tab" style="margin-top: 0.5em">
        <font color="#008000"><i>font-family</i></font><span style="margin-left: 0.25em"></span><img src="font-mechanics-4.png"
        style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434344em; margin-top: -0.0206868686868687em; vertical-align: 0em; height: 0.491313131313131em"></img><span style="margin-left: 0.25em"></span><tt>rm</tt>
      </div>
      <div class="right-tab" style="margin-bottom: 0.25em">
        <font color="#707070">(font variant)</font>
      </div>
    </div>
    <div style="margin-left: 42.175176192px">
      <p>
        This variable selects a variant of the major font, like a sans serif
        font, a typewriter font, and so on. As explained above, variants of a
        given font are designed to mix well together. Physically speaking,
        many fonts do not come with all possible variants (sans serif,
        typewriter, <abbr>etc.</abbr>), in which case TeXmacs tries to fall
        back on a suitable alternative font.
      </p>
    </div>
    <div style="margin-left: 42.175176192px">
      <p>
        Typical variants for text fonts are <tt class="verbatim">rm</tt> (roman), <tt
        class="verbatim">tt</tt> (typewriter) and <tt class="verbatim">ss</tt> (sans serif):
      </p>
    </div>
    <div class="tmweb-code" style="margin-bottom: 0.5em; margin-left: 42.175176192px">
      <p>
        roman, <tt>typewriter</tt> and <class style="font-family: sans-serif">sans serif</class>
      </p>
      <p>
        Sans serif formula: <class style="font-family: sans-serif"><img src="font-mechanics-9.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.0154949494949495em; margin-right: -0.0517171717171721em; margin-top: -0.00711111111111107em; vertical-align: -0.248222222222222em; height: 0.956767676767677em"></img></class>
      </p>
    </div>
    <div class="compact-block" style="text-indent: 0em">
      <div class="left-tab" style="margin-top: 0.5em">
        <font color="#008000"><i>font-series</i></font><span style="margin-left: 0.25em"></span><img src="font-mechanics-4.png"
        style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434344em; margin-top: -0.0206868686868687em; vertical-align: 0em; height: 0.491313131313131em"></img><span style="margin-left: 0.25em"></span><tt>medium</tt>
      </div>
      <div class="right-tab" style="margin-bottom: 0.25em">
        <font color="#707070">(font weight)</font>
      </div>
    </div>
    <div style="margin-left: 42.175176192px">
      <p>
        The font series determines the weight of the font. Most fonts only
        provide <tt class="verbatim">regular</tt> and <tt class="verbatim">bold</tt> font weights.
        Some fonts also provide <tt class="verbatim">light</tt> as a possible value.
      </p>
    </div>
    <div class="tmweb-code" style="margin-bottom: 0.5em; margin-left: 42.175176192px">
      <p>
        light, medium, <b>bold</b>
      </p>
    </div>
    <div class="compact-block" style="text-indent: 0em">
      <div class="left-tab" style="margin-top: 0.5em">
        <font color="#008000"><i>font-shape</i></font><span style="margin-left: 0.25em"></span><img src="font-mechanics-4.png"
        style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434344em; margin-top: -0.0206868686868687em; vertical-align: 0em; height: 0.491313131313131em"></img><span style="margin-left: 0.25em"></span><tt>right</tt>
      </div>
      <div class="right-tab" style="margin-bottom: 0.25em">
        <font color="#707070">(font shape)</font>
      </div>
    </div>
    <div style="margin-left: 42.175176192px">
      <p>
        The font shape determines other characters of a font, like its slant,
        whether we use small capitals, whether it is condensed, and so on. For
        instance,
      </p>
    </div>
    <div class="tmweb-code" style="margin-bottom: 0.5em; margin-left: 42.175176192px">
      <p>
        <class style="font-style: normal">upright</class>, slanted, <i>italic</i>, left slanted,
        <class style="font-variant: small-caps">Small Capitals</class>, <tt>proportional
        typewriter</tt>, <b>bold condensed</b>, <class style="font-family: sans-serif">flat sans
        serif</class>, long
      </p>
    </div>
    <div class="compact-block" style="text-indent: 0em">
      <div class="left-tab" style="margin-top: 0.5em">
        <a id="font-base-size"></a><font color="#008000"><i>font-base-size</i></font><span style="margin-left: 0.25em"></span><img
        src="font-mechanics-4.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434344em; margin-top: -0.0206868686868687em; vertical-align: 0em; height: 0.491313131313131em"></img><span style="margin-left: 0.25em"></span><tt>10</tt>
      </div>
      <div class="right-tab" style="margin-bottom: 0.25em">
        <font color="#707070">(font base size)</font>
      </div>
    </div>
    <div style="margin-left: 42.175176192px">
      <p>
        The base font size is specified in <a href="../basics/lengths.en.html"><tt class="verbatim">pt</tt>
        units</a> and is usually invariant throughout the document. Usually,
        the base font size is <tt class="verbatim">9pt</tt>, <tt class="verbatim">10pt</tt>, <tt
        class="verbatim">11pt</tt> or <tt class="verbatim">12pt</tt>. Other font sizes are usually
        obtained by changing the <a href="env-general.en.html#magnification"><font color="#008000"><i>magnification</i></font></a>
        or the relative <a href="#font-size">font-size</a>.
      </p>
    </div>
    <div class="tmweb-code" style="margin-bottom: 0.5em; margin-left: 42.175176192px">
      <p>
        9pt, 10pt, 11pt, 12pt
      </p>
    </div>
    <div class="compact-block" style="text-indent: 0em">
      <div class="left-tab" style="margin-top: 0.5em">
        <a id="font-size"></a><font color="#008000"><i>font-size</i></font><span style="margin-left: 0.25em"></span><img
        src="font-mechanics-4.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434344em; margin-top: -0.0206868686868687em; vertical-align: 0em; height: 0.491313131313131em"></img><span style="margin-left: 0.25em"></span><tt>1</tt>
      </div>
      <div class="right-tab" style="margin-bottom: 0.25em">
        <font color="#707070">(font size)</font>
      </div>
    </div>
    <div style="margin-left: 42.175176192px">
      <p>
        The real font size is obtained by multiplying the <font color="#008000"><i>font-base-size</i></font>
        by the <font color="#008000"><i>font-size</i></font> multiplier. The following
        standard font sizes are available from <class class="tmweb-menu" style="font-family: sans-serif">Format</class>&rarr;<class
        class="tmweb-menu" style="font-family: sans-serif">Size</class><a id="auto-7"></a>:
      </p>
    </div>
    <div style="margin-left: 42.175176192px; margin-top: 1em; margin-bottom: 1em">
      <table style="width: 100%">
        <tbody><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em"><table style="display: inline-table; vertical-align: middle">
            <tbody><tr>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-left: 0.5px solid; border-left: 1px solid; border-top: 0.5px solid; border-top: 1px solid; border-bottom: 1px solid; background-color: #0000ff20">size</td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-top: 0.5px solid; border-top: 1px solid; border-bottom: 1px solid; background-color: #0000ff20">multiplier</td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-top: 0.5px solid; border-top: 1px solid; border-bottom: 1px solid; background-color: #0000ff20">size</td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-right: 1px solid; border-top: 0.5px solid; border-top: 1px solid; border-bottom: 1px solid; background-color: #0000ff20">multiplier</td>
            </tr><tr>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-left: 0.5px solid; border-left: 1px solid"><font style="font-size: 59.0%">Tiny</font></td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid">0.59</td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid"><font style="font-size: 71.0%">Very small</font></td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-right: 1px solid">0.71</td>
            </tr><tr>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-left: 0.5px solid; border-left: 1px solid"><font style="font-size: 84.0%">Small</font></td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid">0.84</td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid"><font style="font-size: 100%">Normal</font></td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-right: 1px solid">1</td>
            </tr><tr>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-left: 0.5px solid; border-left: 1px solid; padding-bottom: 0.25em; padding-top: 0.25em"><font style="font-size: 119.0%">Large</font></td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; padding-bottom: 0.25em; padding-top: 0.25em">1.19</td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; padding-bottom: 0.25em; padding-top: 0.25em"><font style="font-size: 141.0%">Very large</font></td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-right: 1px solid; padding-bottom: 0.25em; padding-top: 0.25em">1.41</td>
            </tr><tr>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-left: 0.5px solid; border-left: 1px solid; border-bottom: 1px solid; padding-bottom: 0.25em; padding-top: 0.25em"><font style="font-size: 168.0%">Huge</font></td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-bottom: 1px solid; padding-bottom: 0.25em; padding-top: 0.25em">1.68</td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-bottom: 1px solid; padding-bottom: 0.25em; padding-top: 0.25em"><font style="font-size: 200%">Really huge</font></td>
              <td style="border-right: 0.5px solid; border-bottom: 0.5px solid; border-right: 1px solid; border-bottom: 1px solid; padding-bottom: 0.25em; padding-top: 0.25em">2</td>
            </tr></tbody>
          </table></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; height: 0.5em"></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-left: 1.5em; padding-right: 1.5em"><div class="caption">
            <font style="font-size: 90.0%"><p>
              <b>Table 1. </b><a id="auto-8"></a>Standard font sizes.
            </p></font>
          </div></td>
        </tr></tbody>
      </table>
    </div>
    <div style="margin-bottom: 0.5em; margin-left: 42.175176192px">
      <p>
        From a mathematical point of view, the multipliers are in a geometric
        progression with factor <span class="no-breaks"><img src="font-mechanics-10.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.0673333333333333em; margin-right: -0.0103434343434343em; margin-top: 0.0373333333333333em; vertical-align: -0.365212121212121em; height: 1.11191919191919em"></img>.</span>
        Notice that the font size is also affected by the <a href="env-math.en.html#math-level">index
        level</a>.
      </p>
    </div>
    <div class="compact-block" style="text-indent: 0em">
      <div class="left-tab" style="margin-top: 0.5em">
        <font color="#008000"><i>dpi</i></font><span style="margin-left: 0.25em"></span><img src="font-mechanics-4.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434344em; margin-top: -0.0206868686868687em; vertical-align: 0em; height: 0.491313131313131em"></img><span
        style="margin-left: 0.25em"></span><tt>600</tt>
      </div>
      <div class="right-tab" style="margin-bottom: 0.25em">
        <font color="#707070">(fonts rendering quality)</font>
      </div>
    </div>
    <div style="margin-bottom: 0.5em; margin-left: 42.175176192px">
      <p>
        The rendering quality of raster fonts (also called Type 3 fonts), such
        as the fonts generated by the <class style="font-variant: small-caps">Metafont</class> program
        is controlled through its discretization precision in dots per inch.
        Nowadays, most laser printers offer a printing quality of at least <tt
        class="verbatim">600dpi</tt>, which is also the default <font color="#008000"><i>dpi</i></font>
        setting for TeXmacs. For really high quality printing, professionals
        usually use a precision of <tt class="verbatim">1200dpi</tt>. The <font color="#008000"><i>dpi</i></font>
        is usually set once and for all for the whole document.
      </p>
    </div>
    <h2 id="auto-9">4.<span style="margin-left: 1em"></span>Font substition and emulation<span style="margin-left: 1em"></span></h2>
    <p>
      For more details see the paper, J. van der Hoeven,  &ldquo;Mathematical
      font art&rdquo; available at <a href="https://www.texmacs.org/joris/fontart/fontart-abs.html"><tt>https://www.texmacs.org/joris/fontart/fontart-abs.html</tt></a>.
    </p>
    <p>
      The typesetting of technical documents require a large set of glyphs
      which are typically not available in standard fonts. TeXmacs' general
      strategy for turning existing fonts into full fledged mathematical font
      families is to remedy each of the font's insufficiencies. The most
      common problems are the following:
    </p>
    <ul>
      <li>
        <p>
          Lack of the most important font declinations as needed in scientific
          documents: <strong>Bold</strong>, <em>Italic</em>, <class style="font-variant: small-caps">Small
          Capitals</class>, <samp>Sans Serif</samp>, <tt class="verbatim">Typewriter</tt>.
        </p>
      </li>
      <li>
        <p>
          Lack of specific glyphs: non English languages, mathematical
          symbols, and in particular big operators, extensible brackets and
          wide accents.
        </p>
      </li>
      <li>
        <p>
          Inconsistencies: sloppy design of some glyphs that are important for
          mathematics (such as <span class="no-breaks"><img src="font-mechanics-11.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: 0em; height: 0.466020202020202em"></img>,</span>
          <span class="no-breaks"><img src="font-mechanics-12.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: 0em; height: 0.466020202020202em"></img>,</span> <abbr>etc.</abbr>),
          leading to inconsistencies.
        </p>
      </li>
    </ul>
    <p>
      The main countermeasures are <em>font substitution</em> and <em>font
      emulation</em>. The first technique consists of borrowing missing glyphs
      from other fonts. This can either be done on the level of an entire font
      (<abbr>e.g.</abbr> for obtaining bold or italic declinations) or for
      individual characters (<abbr>e.g.</abbr> a missing <img src="font-mechanics-13.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: 0em; height: 0.47579797979798em"></img>
      symbol, or lacking Greek characters). Font emulation consists of
      combining and altering the glyphs of symbols in a font in order to
      generate new ones. This can again be done for entire fonts or individual
      glyphs.
    </p>
    <p>
      A prerequisite for automatic font substitutions is a detailed analysis
      of the main characteristics of all supported fonts. The results of this
      analysis are stored in a database. Using this database, we may then
      compute the distance between two fonts. In the case when a symbol <img
      src="font-mechanics-14.png" style="margin-left: -0.0103434343434343em; margin-bottom: -2.0202020202021e-5em; margin-right: -0.0827474747474747em; margin-top: -0.0201212121212121em; vertical-align: -0.0103232323232323em; height: 0.47579797979798em"></img> is missing in a font <span class="no-breaks"><img src="font-mechanics-15.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0em; margin-right: -0.0103434343434343em; margin-top: -0.0155151515151516em; vertical-align: -0.15169696969697em; height: 0.849878787878788em"></img>,</span>
      it then suffices to find the closest font <img src="font-mechanics-16.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.0103232323232323em; margin-right: -0.0103434343434343em; margin-top: -0.0155151515151516em; vertical-align: -0.162020202020202em; height: 0.849878787878788em"></img> that
      supports this symbol <span class="no-breaks"><img src="font-mechanics-14.png" style="margin-left: -0.0103434343434343em; margin-bottom: -2.0202020202021e-5em; margin-right: -0.0827474747474747em; margin-top: -0.0201212121212121em; vertical-align: -0.0103232323232323em; height: 0.47579797979798em"></img>.</span> Notice
      that the best substitution font may depend on the fonts which are
      installed on your system.
    </p>
    <p>
      In our database we both use discrete font characteristics
      (<abbr>e.g.</abbr> sans serif, small capitals, handwritten, ancient,
      gothic, <abbr>etc.</abbr>) and continuous ones (<abbr>e.g.</abbr> italic
      slant, height of an &ldquo;x&rdquo; symbol, <abbr>etc.</abbr>). Most
      characteristics are determined automatically by analyzing the name of
      the font (for some of the discrete characteristics) or individual glyphs
      (for the continuous ones). Some &ldquo;font categories&rdquo; (such as
      handwritten, gothic, <abbr>etc.</abbr>) can be specified manually.
    </p>
    <p>
      One of the most important font characteristics is the height of the
      &ldquo;x&rdquo; symbol (with respect to the design size). When the font
      <img src="font-mechanics-15.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0em; margin-right: -0.0103434343434343em; margin-top: -0.0155151515151516em; vertical-align: -0.15169696969697em; height: 0.849878787878788em"></img> borrows a symbol from the font <img src="font-mechanics-16.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.0103232323232323em; margin-right: -0.0103434343434343em; margin-top: -0.0155151515151516em; vertical-align: -0.162020202020202em; height: 0.849878787878788em"></img>
      we first scale it by the quotient of these x-heights inside <img src="font-mechanics-15.png"
      style="margin-left: -0.0103434343434343em; margin-bottom: 0em; margin-right: -0.0103434343434343em; margin-top: -0.0155151515151516em; vertical-align: -0.15169696969697em; height: 0.849878787878788em"></img> and <span class="no-breaks"><img src="font-mechanics-16.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.0103232323232323em; margin-right: -0.0103434343434343em; margin-top: -0.0155151515151516em; vertical-align: -0.162020202020202em; height: 0.849878787878788em"></img>.</span>
    </p>
    <p>
      Other common font characteristics are also taken into account into our
      database, such as the italic slant, the width of the &ldquo;M&rdquo;
      symbol, the ascent and descent (above and above the &ldquo;x&rdquo;
      symbol), etc. In addition, we carefully analyze the glyphs themselves in
      order to determine the horizontal and vertical stroke widths for the
      &ldquo;o&rdquo; and &ldquo;O&rdquo; symbols, the average aspect-ratios
      of uppercase and lowercase letters, and the average area of glyphs that
      is filled (how much ink will be used).
    </p>
    <p>
      Font emulation works at the level of glyphs bitmaps, in order to produce
      <strong>Bold</strong>, <em>Italic</em> and <class style="font-variant: small-caps">Small
      Capitals</class> and &ldquo;blackboard bold&rdquo; variations of a given
      font.
    </p>
    <div style="margin-top: 1em; margin-bottom: 1em">
      <table style="width: 100%">
        <tbody><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em"><img src="font-mechanics-17.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.010343434343433em; margin-top: 0em; vertical-align: 0em; height: 15.247898989899em"></img></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; height: 0.5em"></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-left: 1.5em; padding-right: 1.5em"><div class="caption">
            <font style="font-size: 90.0%"><p>
              <b>Figure 1. </b><a id="auto-10"></a>Emulation of bold, italic, small
              capitals and blackboard bold.
            </p><p>
              * These declinations are already supported by the original font.
            </p></font>
          </div></td>
        </tr></tbody>
      </table>
    </div>
    <p>
      Missing glyphs can be generated automatically from existing ones using a
      combination of the following main techniques, listed by increasing
      complexity:
    </p>
    <ul>
      <li>
        <p>
          Superposition of several glyphs: <img src="font-mechanics-18.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0155151515151515em; vertical-align: 0em; height: 0.501656565656566em"></img> and <img
          src="font-mechanics-11.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: 0em; height: 0.466020202020202em"></img> can be combined into <span class="no-breaks"><img src="font-mechanics-19.png"
          style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: 0em; vertical-align: 0em; height: 0.579232323232323em"></img>,</span> and <img src="font-mechanics-20.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: 0em; height: 0.466020202020202em"></img> be obtained by
          juxtaposing two <img src="font-mechanics-12.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: 0em; height: 0.466020202020202em"></img> symbols.
        </p>
      </li>
      <li>
        <p>
          Clipping rectangular areas: cutting <img src="font-mechanics-21.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434345em; margin-top: 0em; vertical-align: 0em; height: 0.47579797979798em"></img> and <img
          src="font-mechanics-22.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0206868686868687em; vertical-align: 0em; height: 0.506828282828283em"></img> in their midsts and combining them yields <span
          class="no-breaks"><img src="font-mechanics-23.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0206868686868687em; vertical-align: 0em; height: 0.506828282828283em"></img>.</span>
        </p>
      </li>
      <li>
        <p>
          Linear transformations: combining a crushed O and an I, we may
          produce the Greek capital &lt;Phi*&gt;. Turning around <span class="no-breaks"><img
          src="font-mechanics-24.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434345em; margin-top: 0em; vertical-align: 0em; height: 0.47579797979798em"></img>,</span> we obtain <span class="no-breaks"><img src="font-mechanics-25.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.00515151515151516em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: -0.237878787878788em; height: 1.06020202020202em"></img>.</span>
        </p>
      </li>
      <li>
        <p>
          Simple graphical constructs such as circles and lines. This can for
          instance be used for producing the missing half circle of <span
          class="no-breaks"><img src="font-mechanics-26.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: 0em; height: 0.466020202020202em"></img>.</span>
        </p>
      </li>
      <li>
        <p>
          Special <em>ad hoc</em> transformations that directly operate on the
          pixels of a glyph (or on their outlines if possible). For instance,
          we designed a special &ldquo;curlyfication&rdquo; method that turns
          <img src="font-mechanics-12.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: 0em; height: 0.466020202020202em"></img> into <img src="font-mechanics-27.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: 0em; height: 0.466020202020202em"></img> and <font
          style="font-size: 120.0%"><img src="font-mechanics-28.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: 0em; height: 0.466020202020202em"></img></font> into <font style="font-size: 120.0%"><img src="font-mechanics-29.png"
          style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: 0em; height: 0.466020202020202em"></img></font>. Similarly, we implemented a &ldquo;flood
          fill&rdquo; algorithm for transforming <img src="font-mechanics-30.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: 0em; height: 0.466020202020202em"></img> into
          <span class="no-breaks"><img src="font-mechanics-31.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: 0em; height: 0.466020202020202em"></img>.</span>
        </p>
      </li>
      <li>
        <p>
          Emulation of uppercase Greek letters is obtained by gluing together
          pieces of certain glyphs to produce others. Lowecase Greek letters
          are not amenable to this approach.
        </p>
      </li>
    </ul>
    <div style="margin-top: 1em; margin-bottom: 1em">
      <table style="width: 100%">
        <tbody><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em"><img src="font-mechanics-32.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.010343434343433em; margin-top: 0em; vertical-align: 0em; height: 15.2045252525253em"></img></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; height: 0.5em"></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-left: 1.5em; padding-right: 1.5em"><div class="caption">
            <font style="font-size: 90.0%"><p>
              <b>Figure 2. </b><a id="auto-11"></a>Emulation of various mathematical
              symbols in various fonts.
            </p></font>
          </div></td>
        </tr></tbody>
      </table>
    </div>
    <p>
      One specific problem with mathematical fonts is the need for rubber
      characters. There are essentially four types of them: big operators
      (<span class="no-breaks"><img src="font-mechanics-2.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.0351111111111111em; margin-right: -0.0103434343434343em; margin-top: -0.0142424242424243em; vertical-align: -0.245737373737374em; height: 0.956767676767677em"></img>,</span> <span class="no-breaks"><img src="font-mechanics-33.png"
      style="margin-left: -0.0103434343434343em; margin-bottom: 0.00925252525252523em; margin-right: -0.0103434343434343em; margin-top: -0.0239191919191919em; vertical-align: -0.240909090909091em; height: 0.982626262626263em"></img>,</span> <span class="no-breaks"><img src="font-mechanics-34.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.0222424242424242em; margin-right: -0.0103434343434345em; margin-top: -0.0109292929292929em; vertical-align: -0.202181818181818em; height: 0.879191919191919em"></img>),</span>
      large delimiters <img src="font-mechanics-35.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.0284646464646465em; margin-right: -0.0103434343434343em; margin-top: -0.0143838383838384em; vertical-align: -0.332848484848485em; height: 1.13777777777778em"></img> <span class="no-breaks"><img src="font-mechanics-36.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.00260606060606061em; margin-right: -0.0103434343434343em; margin-top: -0.00470707070707077em; vertical-align: -0.33769696969697em; height: 1.16363636363636em"></img>,</span>
      wide accents (<span class="no-breaks"><img src="font-mechanics-37.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.0413535353535354em; margin-right: -0.0103434343434343em; margin-top: -0.0103434343434343em; vertical-align: -0.144787878787879em; height: 0.817131313131313em"></img>,</span> <span class="no-breaks"><img
      src="font-mechanics-38.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: -0.0258585858585859em; vertical-align: 0em; height: 0.698161616161616em"></img>),</span> and long arrows (<span class="no-breaks"><img src="font-mechanics-39.png"
      style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: 0.31030303030303em; vertical-align: 0em; height: 0.78949494949495em"></img>,</span> <span class="no-breaks"><img src="font-mechanics-40.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434343em; margin-top: 0.31030303030303em; vertical-align: 0em; height: 0.954989898989899em"></img>).</span>
    </p>
    <p>
      We produce these rubber characters using essentially the same techniques
      as in the previous section. Especially horizontal and vertical scaling
      are very useful, as well as cutting symbols into several parts and
      reassembling them appropriately.
    </p>
    <div style="margin-top: 1em; margin-bottom: 1em">
      <table style="width: 100%">
        <tbody><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em"><p>
            <img src="font-mechanics-41.png" style="margin-left: -0.0103434343434343em; margin-bottom: -0.0103434343434343em; margin-right: -0.0103434343434365em; margin-top: 0em; vertical-align: 0em; height: 9.33171717171717em"></img>
          </p><p>
            
          </p></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; height: 0.5em"></td>
        </tr><tr>
          <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-left: 1.5em; padding-right: 1.5em"><div class="caption">
            <font style="font-size: 90.0%"><p>
              <b>Figure 3. </b><a id="auto-12"></a>Assorted rubber symbols from various
              fonts.
            </p></font>
          </div></td>
        </tr></tbody>
      </table>
    </div>
    <h2 id="auto-13">5.<span style="margin-left: 1em"></span>The abstract font class<span style="margin-left: 1em"></span></h2>
    <p>
      The main abstract <tt class="verbatim">font</tt> class is defined in <tt class="verbatim">font.hpp</tt>:
      
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
struct font_rep: rep&lt;font&gt; {
  int      type;             // font type
  int      math_type;        // For TeX Gyre math fonts and Stix
  SI       size;             // requested size
  SI       design_size;      // design size in points/256
  SI       display_size;     // display size in points/PIXEL
  double   slope;            // italic slope
  space    spc;              // usual space between words
  space    extra;            // extra space at end of words
  space    mspc;             // space after mathematical operator, e.g. log x
  SI       sep;              // separation space between close components

  SI       y1;               // bottom y position
  SI       y2;               // top y position
  SI       yx;               // height of the x character
  SI       yfrac;            // vertical position fraction bar
  SI       ysub_lo_base;     // base line for subscripts
  SI       ysub_hi_lim;      // upper limit for subscripts
  SI       ysup_lo_lim;      // lower limit for supscripts
  SI       ysup_lo_base;     // base line for supscripts
  SI       ysup_hi_lim;      // upper limit for supscripts
  SI       yshift;           // vertical script shift inside fractions

  SI       wpt;              // width of one point in font
  SI       hpt;              // height of one point in font (usually wpt)
  SI       wfn;              // wpt * design size in points
  SI       wline;            // width of fraction bars and so
  SI       wquad;            // quad space (often width of widest character M)

  double   last_zoom;        // last rendered zoom
  font     zoomed_fn;        // zoomed font for last_zoom (or nil)

  // Microtypography extensions are not shown here

  font_rep (string name);
  font_rep (string name, font fn);
  void copy_math_pars (font fn);

  virtual bool   supports (string c) = 0;
  virtual void   get_extents (string s, metric&amp; ex) = 0;
  virtual void   get_extents (string s, metric&amp; ex, bool ligf);
  virtual void   get_extents (string s, metric&amp; ex, SI xk);
  virtual void   get_xpositions (string s, SI* xpos);
  virtual void   get_xpositions (string s, SI* xpos, bool ligf);
  virtual void   get_xpositions (string s, SI* xpos, SI xk);
  virtual void   draw_fixed (renderer ren, string s, SI x, SI y) = 0;
  virtual void   draw_fixed (renderer ren, string s, SI x, SI y, bool ligf);
  virtual void   draw_fixed (renderer ren, string s, SI x, SI y, SI xk);
  virtual font   poor_magnify (double zoomx, double zoomy);
  virtual font   magnify (double zoomx, double zoomy) = 0;
  virtual font   magnify (double zoom);
  virtual void   draw (renderer ren, string s, SI x, SI y, SI xk, bool ext);
  virtual void   draw (renderer ren, string s, SI x, SI y);
  virtual void   draw (renderer ren, string s, SI x, SI y, SI xk);

  // other various minor methods for glyph placements not shown
};</pre>
    </div>
    <pre class="verbatim" xml:space="preserve">
    </pre>
    <p>
      The main abstract routines are <tt class="verbatim">get_extents</tt> and <tt
      class="verbatim">draw</tt>. The first routine determines the logical and physical
      bounding boxes of a graphical representation of a word, the second one
      draws the string on the the screen.
    </p>
    <p>
      The additional data are used for global typesetting using the font. The
      other virtual routines are used for determining additional properties of
      typeset strings.
    </p>
    <h2 id="auto-14">6.<span style="margin-left: 1em"></span>Font selection<span style="margin-left: 1em"></span></h2>
    <p>
      Font selection is initiated in <tt class="verbatim cpp">edit_env_rep::update_font</tt>
      where the variables controlling the current font, family, series, shape,
      size and magnification are extracted from the current environment via
      calls to <tt class="verbatim cpp">edit_env_rep::get_string</tt>. 
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
void
edit_env_rep::update_font () {
  fn_size= (int) (((double) get_int (FONT_BASE_SIZE)) *
                  get_double (FONT_SIZE) + 0.5);
  switch (mode) {
  case 0:
  case 1:
    fn= smart_font (get_string (FONT), get_string (FONT_FAMILY),
                    get_string (FONT_SERIES), get_string (FONT_SHAPE),
                    get_script_size (fn_size, index_level), (int) (magn*dpi));
    break;
  case 2:
    fn= smart_font (get_string (MATH_FONT), get_string (MATH_FONT_FAMILY),
                    get_string (MATH_FONT_SERIES), get_string (MATH_FONT_SHAPE),
                    get_string (FONT), get_string (FONT_FAMILY),
                    get_string (FONT_SERIES), &quot;mathitalic&quot;,
                    get_script_size (fn_size, index_level), (int) (magn*dpi));
    break;
  case 3:
    fn= smart_font (get_string (PROG_FONT), get_string (PROG_FONT_FAMILY),
                    get_string (PROG_FONT_SERIES), get_string (PROG_FONT_SHAPE),
                    get_string (FONT), get_string (FONT_FAMILY) * &quot;-tt&quot;,
                    get_string (FONT_SERIES), get_string (FONT_SHAPE),
                    get_script_size (fn_size, index_level), (int) (magn*dpi));
    break;
  }
  string eff= get_string (FONT_EFFECTS);
  if (N(eff) != 0) fn= apply_effects (fn, eff);
}</pre>
    </div>
    <p>
      Selection proceed according to the current mode <tt class="verbatim cpp">0</tt>, <tt
      class="verbatim cpp">1</tt>, <tt class="verbatim cpp">2</tt> or <tt class="verbatim cpp">3</tt>. See <tt class="verbatim cpp">edit_env_rep::update_mode</tt>
      for the conversion between the environment variable <tt class="verbatim cpp">&quot;mode&quot;</tt>
      and the variables <tt class="verbatim cpp">edit_env_rep::mode</tt> and <tt class="verbatim cpp">edit_env_rep::modeop</tt>.
      Different versions of the function <tt class="verbatim cpp">smart_font()</tt> are
      called: either
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
font smart_font (string family, string variant, string series, string shape,
                 int sz, int dpi);</pre>
    </div>
    <p>
      or (for <tt class="verbatim cpp">&quot;math&quot;</tt> and <tt class="verbatim cpp">&quot;prog&quot;</tt>
      modes)
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
font smart_font (string family, string variant, string series, string shape, 
                 string tfam, string tvar, string tser, string tsh, 
                 int sz, int dpi);            </pre>
    </div>
    <p>
      The second version make some adjustment and call the first version. The
      function reads
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
font
smart_font (string family, string variant, string series, string shape,
            string tfam, string tvar, string tser, string tsh,
            int sz, int dpi) {
  if (!new_fonts) return find_font (family, variant, series, shape, sz, dpi);
  if (tfam == &quot;roman&quot;) tfam= family;
  if (variant != &quot;mr&quot;) {
    if (variant == &quot;ms&quot;) tvar= &quot;ss&quot;;
    if (variant == &quot;mt&quot;) tvar= &quot;tt&quot;;
  }
  if (shape == &quot;right&quot;) tsh= &quot;mathupright&quot;;
  return smart_font (tfam, tvar, tser, tsh, sz, dpi);
}</pre>
    </div>
    <p>
      as we see, in the new font mechanism (selected via the <tt class="verbatim cpp">new_fonts</tt>
      global boolean), we ignore the mode-dependent font selection variables,
      in favour of the main font variables, but we make local adjustement to
      carry over corretly the variant and shape selection.
    </p>
    <h2 id="auto-15">7.<span style="margin-left: 1em"></span>Smart fonts<span style="margin-left: 1em"></span></h2>
    <p>
      A smart font collects and coordinate various physical fonts in order to
      represent the full spectrum of TeXmacs basic entities (TeXmacs universal
      encoding) and handles also various customizations and effects. The
      structure has various fields:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
struct smart_font_rep: font_rep {
  string mfam;
  string family;
  string variant;
  string series;
  string shape;
  string rshape;
  int    sz;
  int    hdpi;
  int    dpi;
  int    math_kind;
  int    italic_nr;

  array&lt;font&gt; fn;
  smart_map   sm;
  
  smart_font_rep (string name, font base_fn, font err_fn,
                string family, string variant,
                string series, string shape, int sz, int hdpi, int vdpi);

  // [&hellip;] methods are not shown here
}</pre>
    </div>
    <p>
      The value of the <tt class="verbatim cpp">family</tt> field can be quite complex for
      smart fonts. A typical font can be instantiated in a TeXmacs document
      with an assignment to the <font color="brown"><i>font</i></font> environment
      variable as such:
    </p>
    <div class="tmweb-code">
      <p>
        <font color="blue">&lt;</font>assign<font color="blue">|</font><font color="#008000"><i>font</i></font><font
        color="blue">|</font><font color="black">mathlarge=TeX Gyre Pagella,cal=TeX Gyre
        Termes,bold-cal=TeX Gyre Termes,frak=TeX Gyre Pagella,Fira</font><font
        color="blue">&gt;</font>
      </p>
    </div>
    <p>
      It is a string with comma separated fields and a final value which
      determines the main family <tt class="verbatim cpp">mfam</tt> while the others
      determine special subfonts for certain groups of entities.
    </p>
    <p>
      A key field which controls the behaviour of the smart font is <tt class="verbatim cpp">math_kind</tt>.
      The possible values are <tt class="verbatim cpp">0,1,2,3</tt> and it is set in the
      constructor of the structure according to the value of the <tt class="verbatim cpp">shape</tt>
      parameter. The value <tt class="verbatim cpp">0</tt> is the default. If <tt class="verbatim cpp">shape</tt>
      is one of <tt class="verbatim cpp">&quot;mathitalic&quot;</tt>, <tt class="verbatim cpp">&quot;mathupright&quot;</tt>,
      <tt class="verbatim cpp">&quot;mathshape&quot;</tt> then <tt class="verbatim cpp">math_kind</tt> is,
      respectively, set to <tt class="verbatim cpp">1,2,3</tt>. This is used to determine
      the shape of alphabetic and Greek characters according to different
      conventions <font color="#800000">[to be completed]</font>.
    </p>
    <p>
      To understand how smart fonts work we can look at one of the entrypoints
      of the font mechanics, the <tt class="verbatim cpp">draw_fixed</tt> method, which
      renders an entity on a graphical device.
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
void
smart_font_rep::draw_fixed (renderer ren, string s, SI x, SI y) {
  int i=0, n= N(s);
  while (i &lt; n) {
    int nr;
    string r= s;
    metric ey;
    advance (s, i, r, nr);
    if (nr &gt;= 0) {
      fn[nr]-&gt;draw_fixed (ren, r, x, y);
      if (i &lt; n) {
        fn[nr]-&gt;get_extents (r, ey);
        x += ey-&gt;x2;
      }
    }
  }
}</pre>
    </div>
    <p>
      In this case it off-loads the real work to a particular <i>subfont</i>
      <tt class="verbatim cpp">fn[nr]</tt> which is determined by a call to the dispatching
      function <tt class="verbatim cpp">smart_font_rep::advance</tt> whose result is to
      obtain a subfont number <tt class="verbatim cpp">nr</tt> and, possibly a different
      representation of the entity in the string <tt class="verbatim cpp">r</tt>. A value
      <tt class="verbatim cpp">-1</tt> for <tt class="verbatim cpp">nr</tt> is considered an invalid font
      and ignored.
    </p>
    <p>
      The <tt class="verbatim cpp">advance</tt> method, scans the input string at the given
      position and looks up the entities using either caching mechanism
      provided by <tt class="verbatim cpp">smart_map</tt>:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
struct smart_map_rep: rep&lt;smart_map&gt; {
  int chv[256];
  hashmap&lt;string,int&gt; cht;
  hashmap&lt;tree,int&gt; fn_nr;
  array&lt;tree&gt; fn_spec;
  array&lt;int&gt; fn_rewr;

public:
  smart_map_rep (string name, tree fn);
  int add_font (tree fn, int rewr);
  int add_char (tree fn, string c);
};</pre>
    </div>
    <p>
      where <tt class="verbatim cpp">chv</tt> give a subfont number for single byte
      characters while <tt class="verbatim cpp">cht</tt> provide subfont lookup for other
      entities. If this lookup returns the invalid subfont <tt class="verbatim cpp">-1</tt>
      then we proceed to determine the appropriate subfont via the <tt class="verbatim cpp">resolve</tt>
      method. Once we got a subfont we may initialize it if needed, and the
      proceed to some rewriting, controlled by the value of smartmap's <tt
      class="verbatim cpp">fn_rewr[nr]</tt> field, according to the values
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
#define REWRITE_NONE            0
#define REWRITE_MATH            1
#define REWRITE_CYRILLIC        2
#define REWRITE_LETTERS         3
#define REWRITE_SPECIAL         4
#define REWRITE_EMULATE         5
#define REWRITE_POOR_BBB        6
#define REWRITE_ITALIC_GREEK    7
#define REWRITE_UPRIGHT_GREEK   8
#define REWRITE_UPRIGHT         9
#define REWRITE_ITALIC         10
#define REWRITE_IGNORE         11</pre>
    </div>
    <p>
      For example, in case <tt class="verbatim cpp">fn_rewr[nr] == REWRITE_MATH</tt> we
      perform a rewriting according to the function
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
static string
rewrite_math (string s) {
  string r;
  int i= 0, n= N(s);
  while (i &lt; n) {
    int start= i;
    tm_char_forwards (s, i);
    if (s[start] == '&lt;' &amp;&amp; start+1 &lt; n &amp;&amp; s[start+1] == '#' &amp;&amp; s[i-1] == '&gt;')
      r &lt;&lt; utf8_to_cork (strict_cork_to_utf8 (s (start, i)));
    else r &lt;&lt; s (start, i);
  }
  return r;
}</pre>
    </div>
    <p>
      Each entity is transformed back and forth from Cork to UTF8, which has
      as effect to transform some entities in unicode points which are
      represented in TeXmacs' encoding as <tt class="verbatim">&lt;#xxxx&gt;</tt>. 
    </p>
    <p>
      Let's make a brief digression on how this is implemented before
      continuing. <tt class="verbatim cpp">utf8_to_cork</tt> is implemented in <tt class="verbatim">converter.cpp</tt>
      and uses a <tt class="verbatim cpp">converter</tt> object instatiated via 
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
converter conv= load_converter (&quot;UTF-8&quot;, &quot;Cork&quot;);</pre>
    </div>
    <p>
      and similarly for <tt class="verbatim cpp">strict_cork_to_utf8</tt>. The relevant code
      which construct the conversion tables is in <tt class="verbatim cpp">converter_rep::load</tt>
      and reads:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
  else if (from==&quot;UTF-8&quot; &amp;&amp; to==&quot;Cork&quot;) {
    hashtree&lt;char,string&gt; dic;
    hashtree_from_dictionary (dic,&quot;corktounicode&quot;, UTF8, BIT2BIT, true);
    hashtree_from_dictionary (dic,&quot;unicode-cork-oneway&quot;, UTF8, BIT2BIT, false);
    hashtree_from_dictionary (dic,&quot;tmuniversaltounicode&quot;, UTF8, BIT2BIT, true);
    hashtree_from_dictionary (dic,&quot;unicode-symbol-oneway&quot;, UTF8, BIT2BIT, true);
    ht = dic;
  }
  if (from==&quot;Strict-Cork&quot; &amp;&amp; to==&quot;UTF-8&quot; ) {
    hashtree&lt;char,string&gt; dic;
    hashtree_from_dictionary (dic,&quot;corktounicode&quot;, BIT2BIT, UTF8, false);
    hashtree_from_dictionary (dic,&quot;cork-unicode-oneway&quot;, BIT2BIT, UTF8, false);
    hashtree_from_dictionary (dic,&quot;tmuniversaltounicode&quot;, BIT2BIT, UTF8, false);
    hashtree_from_dictionary (dic,&quot;symbol-unicode-oneway&quot;, BIT2BIT, UTF8, false);
    hashtree_from_dictionary (dic,&quot;symbol-unicode-math&quot;, BIT2BIT, UTF8, false);
    ht = dic;
  }</pre>
    </div>
    <p>
      the boolean value determine if we construct the direct (<tt class="verbatim cpp">false</tt>)
      or inverse (<tt class="verbatim cpp">true</tt>) mapping. The various tables are
      encoded in Scheme expressions in various files in <tt class="verbatim">$TEXMACS_PATH/langs/encoding</tt>.
      
    </p>
    <h3 id="auto-16">7.1.<span style="margin-left: 1em"></span>Entity resolution<span style="margin-left: 1em"></span></h3>
    <p>
      We go back now to entity resolution in <tt class="verbatim cpp">smart_font</tt>. The
      next step is how <tt class="verbatim cpp">resolve</tt> works. The function is
      overloaded. The basic form is
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
int smart_font_rep::resolve (string c)</pre>
    </div>
    <p>
      which performs some basic dispatching for entities.
    </p>
    <p>
      If <tt class="verbatim cpp">math_kind != 0</tt> we perform the following resolutions:
    </p>
    <ul>
      <li>
        <p>
          Entities <tt class="verbatim">&lt;up-XXX&gt;</tt> are associated to a <tt
          class="verbatim cpp">REWRITE_UPRIGHT</tt> rewrite rule, provided the <tt class="verbatim cpp">fn[SUBFONT_MAIN]</tt>
          font supports the basic character, or entity.
        </p>
      </li>
      <li>
        <p>
          Entities  <tt class="verbatim">&lt;up-XXX&gt;</tt> for greek letters are
          associated to a <tt class="verbatim cpp">REWRITE_UPRIGHT_GREEK</tt> rewrite rule,
          provided the <tt class="verbatim cpp">fn[SUBFONT_MAIN]</tt> font supports it.
        </p>
      </li>
      <li>
        <p>
          Same for italic greek letters.
        </p>
      </li>
      <li>
        <p>
          Several specific entities are associated to the <tt class="verbatim cpp">&quot;italic-math&quot;</tt>
          subfont (e.g. <tt class="verbatim">&lt;imath&gt;</tt>, <tt class="verbatim">&lt;jmath&gt;</tt>,
          <tt class="verbatim">&lt;ell&gt;</tt>).
        </p>
      </li>
      <li>
        <p>
          Special entities (as determined by <tt class="verbatim cpp">is_special</tt>,
          provided some side conditions are not met) are associated to the <tt
          class="verbatim cpp">&quot;special&quot;</tt> subfont which is the <tt class="verbatim cpp">shape=&quot;right&quot;</tt>
          variant of the smart font. They corresponds to various mathematical
          entities including those in the form <tt class="verbatim">&lt;big-XXXX-N&gt;</tt>
          which represent large glyphs or operators.
        </p>
      </li>
      <li>
        <p>
          Other entities are associated to the <tt class="verbatim cpp">&quot;emu-bracket&quot;</tt>
          subfont, if appropriate. See <tt class="verbatim cpp">find_in_emu_bracket</tt>. 
        </p>
      </li>
    </ul>
    <p>
      If these cases do not apply we continue. If the shape is <tt class="verbatim">mathupright</tt>
      and we are looking at the standard <tt class="verbatim">roman</tt> family, we
      lookup the non-alphabetic characters in the standard <tt class="verbatim">mathitalic</tt>
      font with a specific subfont with label <tt class="verbatim cpp">&quot;italic-roman&quot;</tt>:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
  if (mfam == &quot;roman&quot; &amp;&amp; shape == &quot;mathupright&quot; &amp;&amp;
      (variant == &quot;rm&quot; || variant == &quot;ss&quot; || variant == &quot;tt&quot;) &amp;&amp;
      N(c) == 1 &amp;&amp; (c[0] &lt; 'A' || c[0] &gt; 'Z') &amp;&amp; (c[0] &lt; 'a' || c[0] &gt; 'z'))
    return sm-&gt;add_char (tuple (&quot;italic-roman&quot;), c);</pre>
    </div>
    <p>
      At this point we need to take into account the structure of the font <tt
      class="verbatim cpp">family</tt> string. Keep in mind that it might looks like this:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
&quot;mathlarge=TeX Gyre Pagella,cal=TeX Gyre Termes,bold-cal=TeX Gyre Termes,&quot;
&quot;frak=TeX Gyre Pagella,Fira&quot;</pre>
    </div>
    <p>
      This particular syntax is called a <i>font sequence</i>. We split the
      various subfields with something like:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
  array&lt;string&gt; a= trimmed_tokenize (family, &quot;,&quot;);</pre>
    </div>
    <p>
      We call each element a <i>subfont selector</i>. The <i>main font
      (family)</i>  is the first comma separated field which is not a
      substring containing an <tt class="verbatim cpp">&quot;=&quot;</tt> character, can be
      extracted via the <tt class="verbatim">main_family</tt> function and call it the
      <i>main selector</i>. The other selectors are assumed to be pairs of the
      form <tt class="verbatim cpp">&quot;XXX=YYY&quot;</tt>, where the l.h.s. determines a
      particular subrange of entities and the r.h.s. the font to be used for
      their rendering.   
    </p>
    <p>
      For each selector in the <tt class="verbatim cpp">a</tt> array, we perform a
      resolution with
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
int smart_font_rep::resolve (string c, string fam, int attempt)</pre>
    </div>
    <p>
      here the <tt class="verbatim cpp">attempt</tt> variable indicate the number of attemps
      we already perfomed. This function implements the semantics of the font
      sequence string, allowing to choose different fonts for subranges of
      glyphs, or variants (like bold, italic, etc&hellip;). 
    </p>
    <p>
      For selectors <tt class="verbatim cpp">fam</tt> of the form <tt class="verbatim cpp">&quot;selector
      field=selector font&quot;</tt> it checks that the <i>selector field</i>
      matches either the glyph <tt class="verbatim cpp">c</tt> or the indicated selector
      font's characteristics. Selector fields can be of the following types:
    </p>
    <ul>
      <li>
        <p>
          a particular feature, as returned by the <tt class="verbatim cpp">logical_font</tt>
          function applied to the font's characteristics (<tt class="verbatim">family</tt>,
          <tt class="verbatim">variant</tt>, <tt class="verbatim">series</tt> and <tt class="verbatim">rshape</tt>);
        </p>
      </li>
      <li>
        <p>
          an unicode range: one of <tt class="verbatim">latin</tt>, <tt class="verbatim">greek</tt>,
          <tt class="verbatim">cyrillic</tt>, <tt class="verbatim">cjk</tt>, <tt class="verbatim">hiragana</tt>,
          <tt class="verbatim">hangul</tt>, <tt class="verbatim">mathsymbols</tt>, <tt class="verbatim">mathextra</tt>,
          <tt class="verbatim">mathletters</tt>, <tt class="verbatim">mathlarge</tt>, <tt class="verbatim">mathbigops</tt>,
          <tt class="verbatim">mathrubber</tt> (see <tt class="verbatim cpp">in_unicode_range</tt> for
          details);
        </p>
      </li>
      <li>
        <p>
          a mathematical alphabeth range, i.e. one of <tt class="verbatim">bold-math</tt>,
          <tt class="verbatim">italic-math</tt>, <tt class="verbatim">bold-italic-math</tt>, <tt
          class="verbatim">cal</tt>, <tt class="verbatim">bold-cal</tt>, <tt class="verbatim">frak</tt>, <tt
          class="verbatim">bold-frak</tt>, <tt class="verbatim">bbb</tt>, <tt class="verbatim">ss</tt>, <tt
          class="verbatim">bold-ss</tt>, <tt class="verbatim">italic-ss</tt>, <tt class="verbatim">bold-italic-ss</tt>,
          <tt class="verbatim">tt</tt> (see the <tt class="verbatim cpp">substitute_math_letter</tt>
          function);
        </p>
      </li>
      <li>
        <p>
          a particular entity (e.g. <tt class="verbatim">&lt;alpha&gt;</tt> or <tt
          class="verbatim">&lt;ell&gt;</tt>);
        </p>
      </li>
      <li>
        <p>
          a letter range: <tt class="verbatim">digit</tt>, <tt class="verbatim">latin</tt>, <tt
          class="verbatim">latin-bold</tt>, <tt class="verbatim">greek</tt>, <tt class="verbatim">basic-letters</tt>,
          <tt class="verbatim">uppercase-latin</tt>, <tt class="verbatim">uppercase-latin-bold</tt>,
          <tt class="verbatim">lowercase-latin</tt>, <tt class="verbatim">lowercase-latin-bold</tt>,
          <tt class="verbatim">greek-bold</tt>, <tt class="verbatim">uppercase-greek</tt>, <tt
          class="verbatim">uppercase-greek-bold</tt>, <tt class="verbatim">lowecase-greek</tt>,
          <tt class="verbatim">lowecase-greek-bold</tt>, (see the <tt class="verbatim cpp">in_collection</tt>
          function);
        </p>
      </li>
      <li>
        <p>
          the <tt class="verbatim cpp">&quot;!&quot;</tt> character followed by a letter
          range, to exclude a particular range;
        </p>
      </li>
      <li>
        <p>
          a selector in the form <tt class="verbatim cpp">&quot;XXXX:YYYY&quot;</tt> where
          <tt class="verbatim">XXXX</tt> and <tt class="verbatim">YYYY</tt> are TeXmacs entities,
          to match an unicode range.
        </p>
      </li>
    </ul>
    <p>
      In case it does, and we are at the first attempt, it proceed to allocate
      the glyph to the given font following several heuristics.  In
      particular, if the font is the main font (this happens for the last font
      sequence element) we check if <tt class="verbatim cpp">fn[SUBFONT_MAIN]</tt> can
      render the entity, otherwise if the font is not the main font, we need
      to first look up the font and check if we can render the entity. If all
      this does not work we have to do otherwise and look elsewhere for the
      glyph before failing. In particular we have special cases for TeX and
      similar fonts which have a complex resolution of entities for
      mathematical typesetting and we need to instantiate an appropriate <tt
      class="verbatim cpp">math_font</tt> to handle them. This case is determined by the
      function <tt class="verbatim cpp">is_math_family</tt>. Cyrillic and Greek letters have
      also special handling in case the font is <tt class="verbatim">roman</tt>. We
      implement here also the fallback for blackboard bold entities <tt class="verbatim">&lt;bbb-X&gt;</tt>
      with synthetic subfonts with  label <tt class="verbatim cpp">&quot;poor-bbb&quot;</tt>.
      If the entity is an italic letter <tt class="verbatim">&lt;it-X&gt;</tt>, we
      dispatch it to the <tt class="verbatim cpp">&quot;it&quot;</tt> subfont with a <tt
      class="verbatim cpp">REWRITE_ITALIC</tt> semantics. Finally, for the main selector, we
      check the <i>emulated fonts</i> as returned by the <tt class="verbatim cpp">emu_font_names</tt>
      function, in case we find an appropriate match we instantiate a glyph in
      an <tt class="verbatim cpp">&quot;emulate&quot;</tt> subfont.
    </p>
    <p>
      If this first attempt fails the function returns the invalid subfont
      selector <tt class="verbatim cpp">-1</tt>. We check now if the entity is rubber.
      Rubbers are entities like <tt class="verbatim">&lt;large-sqrt-2&gt;</tt> or <tt
      class="verbatim">&lt;left-lparen-4&gt;</tt> which are extensible either
      horizontally or vertically. Whether an entity is rubber or not is
      determined by
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
static bool
is_rubber (string c) {
  return (starts (c, &quot;&lt;large-&quot;) ||
          starts (c, &quot;&lt;left-&quot;) ||
          starts (c, &quot;&lt;right-&quot;) ||
          starts (c, &quot;&lt;mid-&quot;)) &amp;&amp; ends (c, &quot;&gt;&quot;);
}</pre>
    </div>
    <p>
      Note that some rubber entities can be matched in the earlier attemps,
      e.g. by <tt class="verbatim">mathlarge</tt>, <tt class="verbatim">mathbigops</tt> or <tt
      class="verbatim">mathrubber</tt> selectors, and supported by a physical font, e.g.
      by an <tt class="verbatim">unicode_font</tt>s below in Section <a href="#sec:unicode-font">8.2</a>.
      Generally however fonts only support the base size of a rubber glyph,
      e.g. in <tt class="verbatim">$TEXMACS_PATH/langs/encoding/symbol-unicode-oneway.scm</tt>
      we have (among other translations)
    </p>
    <div class="tmweb-code">
      <pre class="verbatim" xml:space="preserve">
(&quot;&lt;large-less-0&gt;&quot;      &quot;&lt;&quot;)
(&quot;&lt;large-gtr-0&gt;&quot;       &quot;&gt;&quot;)
(&quot;&lt;large-(&gt;&quot;           &quot;(&quot;)
(&quot;&lt;large-)&gt;&quot;           &quot;)&quot;)
(&quot;&lt;large-(-0&gt;&quot;         &quot;(&quot;)
(&quot;&lt;large-)-0&gt;&quot;         &quot;)&quot;)
(&quot;&lt;large-[&gt;&quot;           &quot;[&quot;)
(&quot;&lt;large-]&gt;&quot;           &quot;]&quot;)
(&quot;&lt;large-[-0&gt;&quot;         &quot;[&quot;)
(&quot;&lt;large-]-0&gt;&quot;         &quot;]&quot;)
(&quot;&lt;large-lceil&gt;&quot;       &quot;#2308&quot;)
(&quot;&lt;large-rceil&gt;&quot;       &quot;#2309&quot;)
(&quot;&lt;large-lfloor&gt;&quot;      &quot;#230A&quot;)
(&quot;&lt;large-rfloor&gt;&quot;      &quot;#230B&quot;)
(&quot;&lt;large-lceil-0&gt;&quot;     &quot;#2308&quot;)
(&quot;&lt;large-rceil-0&gt;&quot;     &quot;#2309&quot;)
(&quot;&lt;large-lfloor-0&gt;&quot;    &quot;#230A&quot;)
(&quot;&lt;large-rfloor-0&gt;&quot;    &quot;#230B&quot;)</pre>
    </div>
    <p>
      For the other sizes we need larger or strecthed variants of those
      glyphs. This is the job of the rubber fonts, therefore for rubber
      entities which arrive at this point we try to instantiate a substitute
      in the <tt class="verbatim cpp">&quot;rubber&quot;</tt> subfont which tries to render
      the glyph via the best method, and ultimately synthetize it via some
      virtual font, see Section <a href="#sec:rubber">8.1</a>.
    </p>
    <p>
      If the entity is not rubber, the resolution process then restart by
      scanning again all the selectors with an higher <tt class="verbatim cpp">attempt</tt>
      number. At this point, since <tt class="verbatim cpp">attempt&gt;1</tt> the resolution
      however proceed differently. If the entity belongs to some mathematical
      alphabeth as detected via <tt class="verbatim cpp">substitute_math_letter</tt>, then
      we stop further attempts and we dispatch the glyph to one of the
      subfonts for variants of alphabetical glyphs associated with one of the
      keys: 
    </p>
    <p>
      <tt class="verbatim cpp">&quot;bold-math&quot;</tt>, <tt class="verbatim cpp">&quot;italic-math&quot;</tt>,
      <tt class="verbatim cpp">&quot;bold-italic-math&quot;</tt>, <tt class="verbatim cpp">&quot;cal&quot;</tt>,
      <tt class="verbatim cpp">&quot;bold-cal&quot;</tt>, <tt class="verbatim cpp">&quot;frak&quot;</tt>,
      <tt class="verbatim cpp">&quot;bold-frak&quot;</tt>, <tt class="verbatim cpp">&quot;bbb&quot;</tt>,
      <tt class="verbatim cpp">&quot;ss&quot;</tt>, <tt class="verbatim cpp">&quot;bold-ss&quot;</tt>, <tt
      class="verbatim cpp">&quot;italic-ss&quot;</tt>, <tt class="verbatim cpp">&quot;bold-italic-ss&quot;</tt>,
      <tt class="verbatim cpp">&quot;tt&quot;</tt>.
    </p>
    <p>
      If the entity is not a mathematical letter, we need attempt to find a
      suitable replacement font via the use TeXmacs mechanism for searching
      fonts with similar characteristics. This is implemented via the function
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
font closest_font (string family, string variant, string series, string shape,
                 int sz, int dpi, int attempt)</pre>
    </div>
    <p>
      to find an appropriate substitute. We indicate the required entity by
      augmenting the variant field with the unicode range of the required
      glyph, as returned by the <tt class="verbatim cpp">get_unicode_range</tt> function:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
string
get_unicode_range (int code) {
  if (code &lt;= 0x7f) return &quot;ascii&quot;;
  else if (code &gt;= 0x80 &amp;&amp; code &lt;= 0x37f) return &quot;latin&quot;;
  else if (code &gt;= 0x380 &amp;&amp; code &lt;= 0x3ff) return &quot;greek&quot;;
  else if (code &gt;= 0x400 &amp;&amp; code &lt;= 0x4ff) return &quot;cyrillic&quot;;
  else if (code &gt;= 0x3000 &amp;&amp; code &lt;= 0x303f) return &quot;cjk&quot;;
  else if (code &gt;= 0x4e00 &amp;&amp; code &lt;= 0x9fcc) return &quot;cjk&quot;;
  else if (code &gt;= 0xff00 &amp;&amp; code &lt;= 0xffef) return &quot;cjk&quot;;
  else if (code &gt;= 0x3040 &amp;&amp; code &lt;= 0x309F) return &quot;hiragana&quot;;
  else if (code &gt;= 0xac00 &amp;&amp; code &lt;= 0xd7af) return &quot;hangul&quot;;
  else if (code &gt;= 0x2000 &amp;&amp; code &lt;= 0x23ff) return &quot;mathsymbols&quot;;
  else if (code &gt;= 0x2900 &amp;&amp; code &lt;= 0x2e7f) return &quot;mathextra&quot;;
  else if (code &gt;= 0x1d400 &amp;&amp; code &lt;= 0x1d7ff) return &quot;mathletters&quot;;
  else return &quot;&quot;;
}</pre>
    </div>
    <p>
      In case we manage to find a suitable font we instantiate it as a subfont
      with a key of the form
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
tree key= tuple (fam, augmented_variant, series, rshape, as_string (attempt-1));</pre>
    </div>
    <p>
      After a number of attemps determined by <tt class="verbatim cpp">FONT_ATTEMPTS</tt> we
      give up. At this point we try <i>virtual fonts</i> via <tt class="verbatim cpp">find_in_virtual</tt>
      and if successful instantiate the virtual font with key <tt class="verbatim cpp">&quot;virtual&quot;</tt>.
    </p>
    <p>
      Other special cases are dispatched to the  <tt class="verbatim cpp">&quot;other&quot;</tt>
      subfont. Finally we assign the glyph to the  <tt class="verbatim cpp">&quot;error&quot;</tt>
      subfont and show it as a red string. This concludes the description of
      the resolution mechanics. 
    </p>
    <p>
      The semanthics of the subfont keys is determined at the moment we
      instantiated the subfonts in <tt class="verbatim cpp">initialize_font</tt>, as
      follows. The <tt class="verbatim cpp">fn_spec[nr]</tt> field of <tt class="verbatim cpp">smart_map</tt>
      is a tree which specify the kind of font
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
void
smart_font_rep::initialize_font (int nr) {
  if (N(fn) &lt;= nr) fn-&gt;resize (nr+1);
  if (!is_nil (fn[nr])) return;
  array&lt;string&gt; a= tuple_as_array (sm-&gt;fn_spec[nr]);
  if (a[0] == &quot;math&quot;)
    fn[nr]= adjust_subfont (get_math_font (a[1], a[2], a[3], a[4]));
  else if (a[0] == &quot;cyrillic&quot;)
    fn[nr]= adjust_subfont (get_cyrillic_font (a[1], a[2], a[3], a[4]));
  else if (a[0] == &quot;greek&quot;)
    fn[nr]= adjust_subfont (get_greek_font (a[1], a[2], a[3], a[4]));
  else if (a[0] == &quot;subfont&quot;)
    fn[nr]= smart_font_bis (a[1], variant, series, shape, sz, hdpi, dpi);
  else if (a[0] == &quot;special&quot;)
    fn[nr]= smart_font_bis (family, variant, series, &quot;right&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;emu-bracket&quot;)
    fn[nr]= virtual_font (this, &quot;emu-bracket&quot;, sz, hdpi, dpi, false);
  else if (a[0] == &quot;other&quot;) {
    int nvdpi= adjusted_dpi (&quot;roman&quot;, variant, series, &quot;mathitalic&quot;, 1);
    int nhdpi= (hdpi * nvdpi + (dpi&gt;&gt;1)) / dpi;
    fn[nr]= smart_font_bis (&quot;roman&quot;, variant, series, &quot;mathitalic&quot;, sz,
                            nhdpi, nvdpi);
  }
  else if (a[0] == &quot;bold-math&quot;)
    fn[nr]= smart_font_bis (family, variant, &quot;bold&quot;, &quot;right&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;fast-italic&quot;)
    fn[nr]= smart_font_bis (family, variant, series, &quot;italic&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;italic-math&quot;)
    fn[nr]= smart_font_bis (family, variant, series, &quot;italic&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;italic-roman&quot;)
    fn[nr]= smart_font_bis (family, variant, series, &quot;mathitalic&quot;, sz,
                            hdpi, dpi);
  else if (a[0] == &quot;bold-italic-math&quot;)
    fn[nr]= smart_font_bis (family, variant, &quot;bold&quot;, &quot;italic&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;italic-greek&quot;)
    fn[nr]= fn[SUBFONT_MAIN];
  else if (a[0] == &quot;upright-greek&quot;)
    fn[nr]= fn[SUBFONT_MAIN];
  else if (a[0] == &quot;up&quot;)
    fn[nr]= fn[SUBFONT_MAIN];
  else if (a[0] == &quot;it&quot;)
    fn[nr]= smart_font_bis (family, variant, series, &quot;italic&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;tt&quot;)
    fn[nr]= smart_font_bis (family, &quot;tt&quot;, series, &quot;right&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;ss&quot;)
    fn[nr]= smart_font_bis (family, &quot;ss&quot;, series, &quot;right&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;bold-ss&quot;)
    fn[nr]= smart_font_bis (family, &quot;ss&quot;, &quot;bold&quot;, &quot;right&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;italic-ss&quot;)
    fn[nr]= smart_font_bis (family, &quot;ss&quot;, series, &quot;italic&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;bold-italic-ss&quot;)
    fn[nr]= smart_font_bis (family, &quot;ss&quot;, &quot;bold&quot;, &quot;italic&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;cal&quot; &amp;&amp; N(a) == 1)
    fn[nr]= smart_font_bis (family, &quot;calligraphic&quot;, series, &quot;italic&quot;, sz,
                            hdpi, dpi);
  else if (a[0] == &quot;bold-cal&quot;)
    fn[nr]= smart_font_bis (family, &quot;calligraphic&quot;, &quot;bold&quot;, &quot;italic&quot;, sz,
                            hdpi, dpi);
  else if (a[0] == &quot;frak&quot;)
    fn[nr]= smart_font_bis (family, &quot;gothic&quot;, series, &quot;right&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;bold-frak&quot;)
    fn[nr]= smart_font_bis (family, &quot;gothic&quot;, &quot;bold&quot;, &quot;right&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;bbb&quot; &amp;&amp; N(a) == 1)
    fn[nr]= smart_font_bis (family, &quot;outline&quot;, series, &quot;right&quot;, sz, hdpi, dpi);
  else if (a[0] == &quot;virtual&quot;)
    fn[nr]= virtual_font (this, a[1], sz, hdpi, dpi, false);
  else if (a[0] == &quot;emulate&quot;) {
    font vfn= fn[SUBFONT_MAIN];
    if (a[1] != &quot;emu-fundamental&quot;)
      vfn= virtual_font (vfn, &quot;emu-fundamental&quot;, sz, hdpi, dpi, true);
    fn[nr]= virtual_font (vfn, a[1], sz, hdpi, dpi, true);
  }
  else if (a[0] == &quot;poor-bold&quot; &amp;&amp; N(a) == 1) {
    font sfn= smart_font_bis (family, variant, &quot;medium&quot;, shape, sz, hdpi, dpi);
    double emb= 5.0/3.0;
    double fat= ((emb - 1.0) * sfn-&gt;wline) / sfn-&gt;wfn;
    fn[nr]= poor_bold_font (sfn, fat, fat); }
  else if (a[0] == &quot;poor-bbb&quot; &amp;&amp; N(a) == 3) {
    double pw= as_double (a[1]);
    double ph= as_double (a[2]);
    font sfn= smart_font_bis (family, variant, series, &quot;right&quot;, sz, hdpi, dpi);
    fn[nr]= poor_bbb_font (sfn, pw, ph, 1.5*pw); }
  else if (a[0] == &quot;rubber&quot; &amp;&amp; N(a) == 2 &amp;&amp; is_int (a[1])) {
    initialize_font (as_int (a[1]));
    fn[nr]= adjust_subfont (rubber_font (fn[as_int (a[1])]));
    //fn[nr]= adjust_subfont (rubber_unicode_font (fn[as_int (a[1])]));
  }
  else if (a[0] == &quot;ignore&quot;)
    fn[nr]= fn[SUBFONT_MAIN];
  else {
    int  ndpi= adjusted_dpi (a[0], a[1], a[2], a[3], as_int (a[4]));
    font cfn = closest_font (a[0], a[1], a[2], a[3], sz, ndpi, as_int (a[4]));
    fn[nr]= adjust_subfont (cfn);
  }
  //cout &lt;&lt; &quot;Font &quot; &lt;&lt; nr &lt;&lt; &quot;, &quot; &lt;&lt; a &lt;&lt; &quot; -&gt; &quot; &lt;&lt; fn[nr]-&gt;res_name &lt;&lt; &quot;\n&quot;;
  if (fn[nr]-&gt;res_name == res_name) {
    failed_error &lt;&lt; &quot;Font &quot; &lt;&lt; nr &lt;&lt; &quot;, &quot; &lt;&lt; a
                 &lt;&lt; &quot; -&gt; &quot; &lt;&lt; fn[nr]-&gt;res_name &lt;&lt; &quot;\n&quot;;
    FAILED (&quot;substitution font loop detected&quot;);
  }
}</pre>
    </div>
    <p>
      
    </p>
    <h2 id="auto-17"><a id="sec:other"></a>8.<span style="margin-left: 1em"></span>Other fonts<span style="margin-left: 1em"></span></h2>
    <h3 id="auto-18"><a id="sec:rubber"></a>8.1.<span style="margin-left: 1em"></span>Rubber fonts<span style="margin-left: 1em"></span></h3>
    <p>
      Rubber fonts take care of large variants of delimiters like brackets and
      square roots, described by entities like <tt class="verbatim">&lt;large-lceil-X&gt;</tt>
      where <tt class="verbatim">X=0,1,2,3,..</tt> is some small integer. The interface
      is the function
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
font rubber_font (font base);</pre>
    </div>
    <p>
      which returns a font appropriate to render the rubber for a base font
      <tt class="verbatim">base</tt>. It caches the result of a call to 
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
static font
make_rubber_font (font fn) {
  string name= locase_all (fn-&gt;res_name);
  if (starts (name, &quot;stix-&quot;) ||
      starts (name, &quot;stix,&quot;) ||
      occurs (&quot;,stix,&quot;, name) ||
      occurs (&quot;math=stix&quot;, name) ||
      occurs (&quot;mathrubber=stix&quot;, name))
    return rubber_stix_font (fn);
  else if (occurs (&quot;mathlarge=&quot;, name) ||
           occurs (&quot;mathrubber=&quot;, name))
    return fn;
  else if (has_poor_rubber &amp;&amp; fn-&gt;type == FONT_TYPE_UNICODE)
    return poor_rubber_font (fn);
  else if (fn-&gt;type == FONT_TYPE_UNICODE)
    return rubber_unicode_font (fn);
  else
    return fn;
}</pre>
    </div>
    <p>
      There is some special handling for STIX fonts which we ignore for the
      moment, moreover if the family name contain a specific selector for <tt
      class="verbatim">mathlarge</tt> or <tt class="verbatim">mathrubber</tt>, then we instantiate
      the same font, inhibiting any emulation of rubber before the proper
      handling of the selector (as we have seen in <tt class="verbatim cpp">smart_font_rep::resolve</tt>).
      In case the base font is an unicode font, the global bool flag <tt
      class="verbatim cpp">has_poor_rubber</tt> (which by default is <tt class="verbatim cpp">true</tt>)
      controls whether we try to synthetize rubber or we use the font's
      provided one. If everything else is not appropriate we return the base
      font. 
    </p>
    <p>
      A <tt class="verbatim">poor_rubber</tt> font has the duty of rendering TeXmacs
      entities which come in various sizes according to some hard-coded
      heuristics. 
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
struct poor_rubber_font_rep: font_rep {
  font base;
  bool big_flag;
  array&lt;bool&gt; initialized;
  array&lt;font&gt; larger;
  translator virt;

  poor_rubber_font_rep (string name, font base);
  font   get_font (int nr);
  int    search_font (string s, string&amp; r);

 // + virtual methods from the base class
};</pre>
    </div>
    <p>
      It relies on magnified versions of the fonts stored in the <tt class="verbatim cpp">larger</tt>
      field and on virtual fonts to synthetise even larger versions of some of
      the glyphs via the <tt class="verbatim cpp">&quot;emu-large&quot;</tt> virtual font
      (see Section <a href="#sec:virtual-font">8.4</a>). 
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
#define MAGNIFIED_NUMBER 4
#define HUGE_ADJUST 1

poor_rubber_font_rep::poor_rubber_font_rep (string name, font base2):
  font_rep (name, base2), base (base2),
  big_flag (supports_big_operators (base2-&gt;res_name))
{
  this-&gt;copy_math_pars (base);
  initialized &lt;&lt; true;
  larger &lt;&lt; base;
  for (int i=1; i&lt;=2*MAGNIFIED_NUMBER+5; i++) {
    initialized &lt;&lt; false;
    larger &lt;&lt; base;
  }
  virt= load_translator (&quot;emu-large&quot;);
}</pre>
    </div>
    <p>
      The boolean field <tt class="verbatim cpp">big_flag</tt> is <tt class="verbatim cpp">true</tt>
      according to the result of <tt class="verbatim cpp">supports_big_operators</tt>:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
bool
supports_big_operators (string res_name) {
  if (occurs (&quot; Math&quot;, res_name))
    return occurs (&quot;TeX Gyre &quot;, res_name);
  if (occurs (&quot;mathitalic&quot;, res_name))
    return occurs (&quot;bonum&quot;, res_name) ||
           occurs (&quot;pagella&quot;, res_name) ||
           occurs (&quot;schola&quot;, res_name) ||
           occurs (&quot;termes&quot;, res_name);
  return false;
}</pre>
    </div>
    <p>
      It indicates whether the font is capable of rendering bigger version of
      standard operators like sums, products, direct sums, etc<span style="margin-left: 0.16665em"></span>.<span
      style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span> (<span class="no-breaks"><img
      src="font-mechanics-42.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.0351111111111111em; margin-right: -0.0103434343434343em; margin-top: -0.0142424242424243em; vertical-align: -0.245737373737374em; height: 0.956767676767677em"></img>,</span> <span class="no-breaks"><img src="font-mechanics-43.png" style="margin-left: -0.0103434343434343em; margin-bottom: 0.00925252525252523em; margin-right: -0.0103434343434343em; margin-top: -0.0239191919191919em; vertical-align: -0.240909090909091em; height: 0.982626262626263em"></img>,</span>
      &oplus;, <span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span
      style="margin-left: 0.16665em"></span>). Essentially only math fonts are capable of that and in
      the current version of TeXmacs only the math features for TeX Gyre fonts
      are implemented.
    </p>
    <p>
      The field <tt class="verbatim cpp">larger</tt> is an array of <tt class="verbatim cpp">2*MAGNIFIED_NUMBER+5</tt>
      fonts. The meaning of each slot is determined by the <tt class="verbatim cpp">search_font</tt>
      function, which tries to locate the appropriate subfont (as return
      value) for a given TeXmacs entity <tt class="verbatim cpp">s</tt>, eventually mapping
      it to another entity <tt class="verbatim cpp">r</tt>.
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
int
poor_rubber_font_rep::search_font (string s, string&amp; r) {
  if (starts (s, &quot;&lt;big-&quot;) &amp;&amp; (ends (s, &quot;-1&gt;&quot;) || ends (s, &quot;-2&gt;&quot;))) {
    r= s;
    if (starts (s, &quot;&lt;big-iint&quot;) || starts (s, &quot;&lt;big-iiint&quot;) ||
        starts (s, &quot;&lt;big-iiiint&quot;) || starts (s, &quot;&lt;big-oint&quot;) ||
        starts (s, &quot;&lt;big-oiint&quot;) || starts (s, &quot;&lt;big-oiiint&quot;) ||
        starts (s, &quot;&lt;big-upiint&quot;) || starts (s, &quot;&lt;big-upiiint&quot;) ||
        starts (s, &quot;&lt;big-upiiiint&quot;) || starts (s, &quot;&lt;big-upoint&quot;) ||
        starts (s, &quot;&lt;big-upoiint&quot;) || starts (s, &quot;&lt;big-upoiiint&quot;) ||
        starts (s, &quot;&lt;big-amalg&quot;) || starts (s, &quot;&lt;big-pluscup&quot;))
      if (!big_flag) return 2*MAGNIFIED_NUMBER + 5;
    if (starts (s, &quot;&lt;big-idotsint&quot;) || starts (s, &quot;&lt;big-upidotsint&quot;) ||
        starts (s, &quot;&lt;big-triangleup&quot;) || starts (s, &quot;&lt;big-box&quot;) ||
        starts (s, &quot;&lt;big-parallel&quot;) || starts (s, &quot;&lt;big-interleave&quot;))
      return 2*MAGNIFIED_NUMBER + 5;
    if (big_flag &amp;&amp; ends (s, &quot;-1&gt;&quot;) &amp;&amp; base-&gt;supports (s)) return 0;
    return 2*MAGNIFIED_NUMBER + 4;
  }
  if (starts (s, &quot;&lt;mid-&quot;)) s= &quot;&lt;left-&quot; * s (5, N(s));
  if (starts (s, &quot;&lt;right-&quot;)) s= &quot;&lt;left-&quot; * s (7, N(s));
  if (starts (s, &quot;&lt;large-&quot;)) s= &quot;&lt;left-&quot; * s (7, N(s));
  if (starts (s, &quot;&lt;left-&quot;)) {
    int pos= search_backwards (&quot;-&quot;, N(s), s), num;
    if (pos &gt; 6) { r= s (6, pos); num= as_int (s (pos+1, N(s)-1)); }
    else { r= s (6, N(s)-1); num= 0; }
    //cout &lt;&lt; &quot;Search &quot; &lt;&lt; base-&gt;res_name &lt;&lt; &quot;, &quot; &lt;&lt; s
    //     &lt;&lt; &quot;, &quot; &lt;&lt; r &lt;&lt; &quot;, &quot; &lt;&lt; num &lt;&lt; LF;
    int nr= max (num - 5, 0);
    int thin= (is_thin (r)? 1: 0);
    int code;
    if (num &lt;= MAGNIFIED_NUMBER ||
        r == &quot;/&quot; || r == &quot;\\&quot; ||
        r == &quot;langle&quot; || r == &quot;rangle&quot; ||
        r == &quot;llangle&quot; || r == &quot;rrangle&quot;) {
      num= min (num, MAGNIFIED_NUMBER);
      if (N(r) &gt; 1) r= &quot;&lt;&quot; * r * &quot;&gt;&quot;;
      if (N(r)&gt;1 &amp;&amp; !base-&gt;supports (r)) {
        if (r == &quot;&lt;||&gt;&quot;) r= &quot;&lt;emu-dbar&gt;&quot;;
        else if (r == &quot;&lt;interleave&gt;&quot;) r= &quot;&lt;emu-tbar&gt;&quot;;
        else if (r == &quot;&lt;llbracket&gt;&quot;) r= &quot;&lt;emu-dlbracket&gt;&quot;;
        else if (r == &quot;&lt;rrbracket&gt;&quot;) r= &quot;&lt;emu-drbracket&gt;&quot;;
        else r= &quot;&lt;emu-&quot; * r (1, N(r)-1) * &quot;&gt;&quot;;
      }
      else if (r == &quot;\\&quot; &amp;&amp; base-&gt;supports (&quot;/&quot;)) {
        metric ex1, ex2;
        base -&gt; get_extents (&quot;/&quot;, ex1);
        base -&gt; get_extents (&quot;\\&quot;, ex2);
        double h1= ex1-&gt;y2 - ex1-&gt;y1;
        double h2= ex2-&gt;y2 - ex2-&gt;y1;
        if (fabs ((h2/h1) - 1.0) &gt; 0.05) r= &quot;&lt;emu-backslash&gt;&quot;;
      }
      return 2*num + thin;
    }
    else if (r == &quot;(&quot;)
      code= virt-&gt;dict [&quot;&lt;rubber-lparenthesis-#&gt;&quot;];
    else if (r == &quot;)&quot;)
      code= virt-&gt;dict [&quot;&lt;rubber-rparenthesis-#&gt;&quot;];
    else if (r == &quot;[&quot;)
      code= virt-&gt;dict [&quot;&lt;rubber-lbracket-#&gt;&quot;];
    else if (r == &quot;]&quot;)
      code= virt-&gt;dict [&quot;&lt;rubber-rbracket-#&gt;&quot;];
    else if (r == &quot;{&quot;)
      code= virt-&gt;dict [&quot;&lt;rubber-lcurly-#&gt;&quot;];
    else if (r == &quot;}&quot;)
      code= virt-&gt;dict [&quot;&lt;rubber-rcurly-#&gt;&quot;];
    else if (r == &quot;|&quot;)
      code= virt-&gt;dict [&quot;&lt;rubber-bar-#&gt;&quot;];
    else if (r == &quot;||&quot;) {
      if (base-&gt;supports (&quot;&lt;||&gt;&quot;))
        code= virt-&gt;dict [&quot;&lt;rubber-parallel-#&gt;&quot;];
      else code= virt-&gt;dict [&quot;&lt;rubber-parallel*-#&gt;&quot;];
    }
    else if (r == &quot;interleave&quot;) {
      if (base-&gt;supports (&quot;&lt;interleave&gt;&quot;))
        code= virt-&gt;dict [&quot;&lt;rubber-interleave-#&gt;&quot;];
      else code= virt-&gt;dict [&quot;&lt;rubber-interleave*-#&gt;&quot;];
    }
    else if (r == &quot;lfloor&quot; || r == &quot;rfloor&quot; ||
             r == &quot;lceil&quot; || r == &quot;rceil&quot; ||
             r == &quot;llbracket&quot; || r == &quot;rrbracket&quot;) {
      if (base-&gt;supports (&quot;&lt;&quot; * r * &quot;&gt;&quot;))
        code= virt-&gt;dict [&quot;&lt;rubber-&quot; * r * &quot;-#&gt;&quot;];
      else code= virt-&gt;dict [&quot;&lt;rubber-&quot; * r * &quot;*-#&gt;&quot;];
    }
    else if (r == &quot;dlfloor&quot; || r == &quot;drfloor&quot; ||
             r == &quot;dlceil&quot; || r == &quot;drceil&quot; ||
             r == &quot;tlbracket&quot; || r == &quot;trbracket&quot; ||
             r == &quot;tlfloor&quot; || r == &quot;trfloor&quot; ||
             r == &quot;tlceil&quot; || r == &quot;trceil&quot;)
      code= virt-&gt;dict [&quot;&lt;rubber-&quot; * r * &quot;-#&gt;&quot;];
    else if (r == &quot;sqrt&quot;) {
      code= virt-&gt;dict [&quot;&lt;rubber-sqrt-#&gt;&quot;];
      r= string ((char) code) * as_string (nr + HUGE_ADJUST) * &quot;&gt;&quot;;
      return 2*MAGNIFIED_NUMBER + 5;
    }
    else
      code= virt-&gt;dict [&quot;&lt;rubber-lparenthesis-#&gt;&quot;];
    
    r= string ((char) code) * as_string (nr + HUGE_ADJUST) * &quot;&gt;&quot;;
    return 2*MAGNIFIED_NUMBER + 2 + thin;
  }
  r= s;
  return 0;
}</pre>
    </div>
    <p>
      The coding of this function is relatively straighfoward.
    </p>
    <p>
      For entities of the form <tt class="verbatim">&lt;big-XXXX-N&gt;</tt> with <tt
      class="verbatim">N=1,2</tt> we use the subfont of index <tt class="verbatim cpp">2*MAGNIFIED_NUMBER
      + 5</tt> is used if <tt class="verbatim cpp">big_flag</tt> is <tt class="verbatim cpp">false</tt> or
      in case <tt class="verbatim cpp">big_flag</tt> is <tt class="verbatim cpp">true</tt>, for the big
      variants with <tt class="verbatim">N=2</tt> while for those at <tt class="verbatim">N=1</tt>
      the base font is used. The subfont at index <tt class="verbatim cpp">2*MAGNIFIED_NUMBER
      + 4</tt> is used in this case for the <tt class="verbatim">N=2</tt> sized glyphs. 
    </p>
    <p>
      Otherwise we normalize all entities of the form  <tt class="verbatim">&lt;left-XXXX-N&gt;</tt>,
      <tt class="verbatim">&lt;mid-XXXX-N&gt;</tt>,  <tt class="verbatim">&lt;right-XXXX-N&gt;</tt>,
      into  <tt class="verbatim">&lt;large-XXXX-N&gt;</tt> and extract the value of <tt
      class="verbatim">N</tt>. For small values of <tt class="verbatim">N</tt> we use the subfont
      at index <tt class="verbatim cpp">2*N+thin</tt> where <tt class="verbatim cpp">thin=0,1</tt>
      according to the return value of the <tt class="verbatim cpp">is_thin</tt> function:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
static hashset&lt;string&gt; thin_delims;

static bool
is_thin (string s) {
  if (N(thin_delims) == 0)
    thin_delims &lt;&lt; string (&quot;|&quot;) &lt;&lt; string (&quot;||&quot;) &lt;&lt; string (&quot;interleave&quot;)
                &lt;&lt; string (&quot;[&quot;) &lt;&lt; string (&quot;]&quot;)
                &lt;&lt; string (&quot;lfloor&quot;) &lt;&lt; string (&quot;rfloor&quot;)
                &lt;&lt; string (&quot;lceil&quot;) &lt;&lt; string (&quot;rceil&quot;)
                &lt;&lt; string (&quot;llbracket&quot;) &lt;&lt; string (&quot;rrbracket&quot;)
                &lt;&lt; string (&quot;dlfloor&quot;) &lt;&lt; string (&quot;drfloor&quot;)
                &lt;&lt; string (&quot;dlceil&quot;) &lt;&lt; string (&quot;drceil&quot;)
                &lt;&lt; string (&quot;tlbracket&quot;) &lt;&lt; string (&quot;trbracket&quot;)
                &lt;&lt; string (&quot;tlfloor&quot;) &lt;&lt; string (&quot;trfloor&quot;)
                &lt;&lt; string (&quot;tlceil&quot;) &lt;&lt; string (&quot;trceil&quot;);
  return thin_delims-&gt;contains (s);
}</pre>
    </div>
    <p>
      For larger glyphs we fallback to the appropriate parametrized glyph in
      the virtual font encoding the value of the size parameter in the
      rewriting entity <tt class="verbatim cpp">r</tt> (see the virtual font for how this
      precisely works).
    </p>
    <p>
      The physical font associated to each subfont index is determined by the
      <tt class="verbatim cpp">get_font</tt> method:  
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
font
poor_rubber_font_rep::get_font (int nr) {
  ASSERT (nr &lt; N(larger), &quot;wrong font number&quot;);
  if (initialized[nr]) return larger[nr];
  initialized[nr]= true;
  if (nr &lt;= 2*MAGNIFIED_NUMBER + 1) {
    int hnr= nr / 2;
    double zoomy= pow (2.0, ((double) hnr) / 4.0);
    double zoomx= sqrt (zoomy);
    if ((nr &amp; 1) == 1) zoomx= sqrt (zoomx);
    larger[nr]= poor_stretched_font (base, zoomx, zoomy);
    //larger[nr]= base-&gt;magnify (zoomx, zoomy);
  }
  else if (nr == 2*MAGNIFIED_NUMBER + 2 || nr == 2*MAGNIFIED_NUMBER + 3) {
    int hdpi= (72 * base-&gt;wpt + (PIXEL/2)) / PIXEL;
    int vdpi= (72 * base-&gt;hpt + (PIXEL/2)) / PIXEL;
    font vfn= virtual_font (base, &quot;emu-large&quot;, base-&gt;size, hdpi, vdpi, false);
    double zoomy= pow (2.0, ((double) MAGNIFIED_NUMBER) / 4.0);
    double zoomx= sqrt (zoomy);
    if ((nr &amp; 1) == 1) zoomx= sqrt (zoomx);
    larger[nr]= poor_stretched_font (vfn, zoomx, zoomy);
    //larger[nr]= vfn-&gt;magnify (zoomx, zoomy);
  }
  else if (nr == 2*MAGNIFIED_NUMBER + 5) {
    int hdpi= (72 * this-&gt;wpt + (PIXEL/2)) / PIXEL;
    int vdpi= (72 * this-&gt;hpt + (PIXEL/2)) / PIXEL;
    font vfn= virtual_font (this, &quot;emu-large&quot;, this-&gt;size, hdpi, vdpi, false);
    larger[nr]= vfn;
  }
  else
    larger[nr]= rubber_unicode_font (base);
  return larger[nr];
}</pre>
    </div>
    <p>
      which dispatches as follows:
    </p>
    <ul>
      <li>
        <p>
          it associates magnified versions of the font to all indexed from <tt
          class="verbatim cpp">0</tt> to <tt class="verbatim cpp">2*MAGNIFIED_NUMBER + 1</tt> with the
          index of the form <tt class="verbatim cpp">2*n+0</tt> horizontally zoomed via the
          square root of the vertical zoom and those with index  <tt class="verbatim cpp">2*n+1</tt>,
          zoomed horizontally with the fourth root of the vertical zoom to
          make them more elongated;
        </p>
      </li>
      <li>
        <p>
          the index <tt class="verbatim cpp">2*MAGNIFIED_NUMBER + 2</tt> and <tt class="verbatim cpp">2*MAGNIFIED_NUMBER
          + 3</tt> are associated to normal and thin versions of magnified <tt
          class="verbatim cpp">&quot;emu-large&quot;</tt> virtual glyphs;
        </p>
      </li>
      <li>
        <p>
          while <tt class="verbatim cpp">2*MAGNIFIED_NUMBER + 5</tt> to normal versions of
          the virtual font;
        </p>
      </li>
      <li>
        <p>
          and finally <tt class="verbatim cpp">2*MAGNIFIED_NUMBER + 4</tt> to the <tt class="verbatim cpp">rubber_unicode_font</tt>
          based on the same font as this rubbert font.
        </p>
      </li>
    </ul>
    <h3 id="auto-19"><a id="sec:unicode-font"></a>8.2.<span style="margin-left: 1em"></span>Unicode fonts<span style="margin-left: 1em"></span></h3>
    <p>
      Unicode fontsare capable of indexing unicode glyphs in physical fonts
      (i.e. modern TrueType, or OpenType font files which can handle the whole
      unicode space without special encodings) 
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
struct unicode_font_rep: font_rep {
  string      family;
  int         hdpi;
  int         vdpi;
  font_metric fnm;
  font_glyphs fng;
  int         ligs;

  hashmap&lt;string,int&gt; native; // additional native (non unicode) characters
  
  unicode_font_rep (string name, string family, int size, int hdpi, int vdpi);
  void tex_gyre_operators ();

  unsigned int read_unicode_char (string s, int&amp; i);
  unsigned int ligature_replace (unsigned int c, string s, int&amp; i);
  
  // + virtual functions from the base class
};</pre>
    </div>
    <p>
      The constructors set the <tt class="verbatim cpp">font_rep::type</tt> field to <tt
      class="verbatim cpp">FONT_TYPE_UNICODE</tt>, load the metric and glyph informatations
      from the font file which is (ultimately) retrieved via the function
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
tt_face load_tt_face (string name);</pre>
    </div>
    <p>
      and initializes the various metric information with values from the
      physical font and suitable heuristics for the mathematical measurements:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
  // in unicode_font_rep::unicode_font_rep (&hellip;) 

  // get main font parameters
  metric ex;
  get_extents (&quot;f&quot;, ex);
  y1= ex-&gt;y1;
  y2= ex-&gt;y2;
  get_extents (&quot;p&quot;, ex);
  y1= min (y1, ex-&gt;y1);
  y2= max (y2, ex-&gt;y2);
  get_extents (&quot;d&quot;, ex);
  y1= min (y1, ex-&gt;y1);
  y2= max (y2, ex-&gt;y2);
  display_size = y2-y1;
  design_size  = size &lt;&lt; 8;

  // get character dimensions
  get_extents (&quot;x&quot;, ex);
  yx           = ex-&gt;y2;
  get_extents (&quot;M&quot;, ex);
  wquad        = ex-&gt;x2;

  // compute other heights
  yfrac        = yx &gt;&gt; 1;
  ysub_lo_base = -yx/3;
  ysub_hi_lim  = (5*yx)/6;
  ysup_lo_lim  = yx/2;
  ysup_lo_base = (5*yx)/6;
  ysup_hi_lim  = yx;
  yshift       = yx/6;

  // compute other widths
  wpt          = (hdpi*PIXEL)/72;
  hpt          = (vdpi*PIXEL)/72;
  wfn          = (wpt*design_size) &gt;&gt; 8;
  wline        = wfn/20;

  // get fraction bar parameters; reasonable compromise between several fonts
  if (supports (&quot;&lt;#2212&gt;&quot;)) get_extents (&quot;&lt;#2212&gt;&quot;, ex);
  else if (supports (&quot;+&quot;)) get_extents (&quot;+&quot;, ex);
  else if (supports (&quot;-&quot;)) get_extents (&quot;-&quot;, ex);
  else get_extents (&quot;x&quot;, ex);
  yfrac= (ex-&gt;y1 + ex-&gt;y2) &gt;&gt; 1;
  if (supports (&quot;&lt;#2212&gt;&quot;) || supports (&quot;+&quot;) || supports (&quot;-&quot;)) {
    wline= ex-&gt;y2 - ex-&gt;y1;
    if (supports (&quot;&lt;#2212&gt;&quot;));
    else if (supports (&quot;&lt;#2013&gt;&quot;)) {
      get_extents (&quot;&lt;#2013&gt;&quot;, ex);
      wline= min (wline, ex-&gt;y2 - ex-&gt;y1);
    }
    wline= max (min (wline, wfn/8), wfn/48);
    if (!supports (&quot;&lt;#2212&gt;&quot;)) yfrac += wline/4;
  }
  if (starts (res_name, &quot;unicode:Papyrus.&quot;)) wline= (2*wline)/3;

  // get space length
  get_extents (&quot; &quot;, ex);
  spc  = space ((3*(ex-&gt;x2-ex-&gt;x1))&gt;&gt;2, ex-&gt;x2-ex-&gt;x1, (3*(ex-&gt;x2-ex-&gt;x1))&gt;&gt;1);
  extra= spc/2;
  mspc = spc;
  sep  = wfn/10;

  // get_italic space
  get_extents (&quot;f&quot;, ex);
  SI italic_spc= (ex-&gt;x4-ex-&gt;x3)-(ex-&gt;x2-ex-&gt;x1);
  slope= ((double) italic_spc) / ((double) display_size) - 0.05;
  if (slope&lt;0.15) slope= 0.0;

  // determine whether we are dealing with a monospaced font
  get_extents (&quot;m&quot;, ex);
  SI em= ex-&gt;x2 - ex-&gt;x1;
  get_extents (&quot;i&quot;, ex);
  SI ei= ex-&gt;x2 - ex-&gt;x1;
  bool mono= (em == ei);</pre>
    </div>
    <p>
      sets the available common ligatures
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
  // available standard ligatures
  if (!mono) {
    if (fnm-&gt;exists (0xfb00)) ligs += LIGATURE_FF;
    if (fnm-&gt;exists (0xfb01)) ligs += LIGATURE_FI;
    if (fnm-&gt;exists (0xfb02)) ligs += LIGATURE_FL;
    if (fnm-&gt;exists (0xfb03)) ligs += LIGATURE_FFI;
    if (fnm-&gt;exists (0xfb04)) ligs += LIGATURE_FFL;
    if (fnm-&gt;exists (0xfb05)) ligs += LIGATURE_FT;
    //if (fnm-&gt;exists (0xfb06)) ligs += LIGATURE_ST;
  }
  if (family == &quot;Times New Roman&quot;)
    ligs= LIGATURE_FI + LIGATURE_FL;
  if (family == &quot;Zapfino&quot;)
    ligs= LIGATURE_FF + LIGATURE_FI + LIGATURE_FL + LIGATURE_FFI;
  //cout &lt;&lt; &quot;ligs= &quot; &lt;&lt; ligs &lt;&lt; &quot;, &quot; &lt;&lt; family &lt;&lt; &quot;, &quot; &lt;&lt; size &lt;&lt; &quot;\n&quot;;</pre>
    </div>
    <p>
      initialize the translation table for Unicode native glyphs for TeX Gyre
      fonts, which at the moment are the only ones with this particular
      feature implemented in TeXmacs,
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
  // direct translations for certain characters without Unicode names
  if (starts (family, &quot;texgyre&quot;) &amp;&amp; ends (family, &quot;-math&quot;))
    tex_gyre_operators ();</pre>
    </div>
    <p>
      and finally initialize microtypographic adjustements (in <tt class="verbatim cpp">lsub_correct</tt>,
      <tt class="verbatim cpp">lsup_correct</tt>, <span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span
      style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span> fields of <tt class="verbatim cpp">font_rep</tt>)
      which are hard-coded in TeXmacs for some of the &ldquo;curated&rdquo;
      fonts, for example:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
  if (starts (family, &quot;STIX-&quot;)) {
    if (!ends (family, &quot;italic&quot;)) {
      global_rsub_correct= (SI) (0.04 * wfn);
      global_rsup_correct= (SI) (0.04 * wfn);
      lsub_correct= lsub_stix_table ();
      lsup_correct= lsup_stix_table ();
      rsub_correct= rsub_stix_table ();
      rsup_correct= rsup_stix_table ();
      above_correct= above_stix_table ();
    }
    else {
      global_rsub_correct= (SI) (0.04 * wfn);
      global_rsup_correct= (SI) (0.04 * wfn);
      lsub_correct= lsub_stix_italic_table ();
      lsup_correct= lsup_stix_italic_table ();
      rsub_correct= rsub_stix_italic_table ();
      rsup_correct= rsup_stix_italic_table ();
      above_correct= above_stix_italic_table ();
    }
  }
  // other cases for TeX Gyre fonts, Papyrus, Linux Libertine &amp; Biolinum, Fira, not shown
}</pre>
    </div>
    <p>
      
    </p>
    <p>
      The <tt class="verbatim cpp">tex_gyre_native</tt> function initialize lookup table to
      find entities (for mathematical typography) which are not mapped in the
      standardized unicode points but in the private areas and in a
      font-dependent manner. It might be interesting to see how it is coded to
      haev an idea of the range of glyphs involved in the re-mapping:
    </p>
    <table style="width: 100%">
      <tbody><tr>
        <td style="width: 50%; vertical-align: top; padding-left: 0em"><div class="tmweb-code">
          <pre class="verbatim cpp" xml:space="preserve">
static hashmap&lt;string,int&gt;
tex_gyre_native () {
  static hashmap&lt;string,int&gt; native;
  if (N(native) != 0) return native;
  native (&quot;&lt;big-prod-2&gt;&quot;)= 4215;
  native (&quot;&lt;big-amalg-2&gt;&quot;)= 4216;
  native (&quot;&lt;big-sum-2&gt;&quot;)= 4217;
  native (&quot;&lt;big-int-2&gt;&quot;)= 4149;
  native (&quot;&lt;big-iint-2&gt;&quot;)= 4150;
  native (&quot;&lt;big-iiint-2&gt;&quot;)= 4151;
  native (&quot;&lt;big-iiiint-2&gt;&quot;)= 4152;
  native (&quot;&lt;big-oint-2&gt;&quot;)= 4153;
  native (&quot;&lt;big-oiint-2&gt;&quot;)= 4154;
  native (&quot;&lt;big-oiiint-2&gt;&quot;)= 4155;
  native (&quot;&lt;big-wedge-2&gt;&quot;)= 3833;
  native (&quot;&lt;big-vee-2&gt;&quot;)= 3835;
  native (&quot;&lt;big-cap-2&gt;&quot;)= 3827;
  native (&quot;&lt;big-cup-2&gt;&quot;)= 3829;
  native (&quot;&lt;big-odot-2&gt;&quot;)= 3864;
  native (&quot;&lt;big-oplus-2&gt;&quot;)= 3868;
  native (&quot;&lt;big-otimes-2&gt;&quot;)= 3873;
  native (&quot;&lt;big-pluscup-2&gt;&quot;)= 3861;
  native (&quot;&lt;big-sqcap-2&gt;&quot;)= 3852;
  native (&quot;&lt;big-sqcup-2&gt;&quot;)= 3854;
  native (&quot;&lt;big-intlim-2&gt;&quot;)= 4149;
  native (&quot;&lt;big-iintlim-2&gt;&quot;)= 4150;
  native (&quot;&lt;big-iiintlim-2&gt;&quot;)= 4151;
  native (&quot;&lt;big-iiiintlim-2&gt;&quot;)= 4152;
  native (&quot;&lt;big-ointlim-2&gt;&quot;)= 4153;
  native (&quot;&lt;big-oiintlim-2&gt;&quot;)= 4154;
  native (&quot;&lt;big-oiiintlim-2&gt;&quot;)= 4155;
  native (&quot;&lt;big-upint-2&gt;&quot;)= 4149;
  native (&quot;&lt;big-upiint-2&gt;&quot;)= 4150;
  native (&quot;&lt;big-upiiint-2&gt;&quot;)= 4151;
  native (&quot;&lt;big-upiiiint-2&gt;&quot;)= 4152;
  native (&quot;&lt;big-upoint-2&gt;&quot;)= 4153;
  native (&quot;&lt;big-upoiint-2&gt;&quot;)= 4154;
  native (&quot;&lt;big-upoiiint-2&gt;&quot;)= 4155;
  native (&quot;&lt;big-upintlim-2&gt;&quot;)= 4149;
  native (&quot;&lt;big-upiintlim-2&gt;&quot;)= 4150;
  native (&quot;&lt;big-upiiintlim-2&gt;&quot;)= 4151;
  native (&quot;&lt;big-upiiiintlim-2&gt;&quot;)= 4152;
  native (&quot;&lt;big-upointlim-2&gt;&quot;)= 4153;
  native (&quot;&lt;big-upoiintlim-2&gt;&quot;)= 4154;
  native (&quot;&lt;big-upoiiintlim-2&gt;&quot;)= 4155;
  
  
  native (&quot;&lt;large-sqrt-1&gt;&quot;)= 4136;
  native (&quot;&lt;large-sqrt-2&gt;&quot;)= 4148;
  native (&quot;&lt;large-sqrt-3&gt;&quot;)= 4160;
  native (&quot;&lt;large-sqrt-4&gt;&quot;)= 4172;
  native (&quot;&lt;large-sqrt-5&gt;&quot;)= 4184;
  native (&quot;&lt;large-sqrt-6&gt;&quot;)= 4196;
</pre>
        </div></td>
        <td style="width: 50%; vertical-align: top; padding-right: 0em"><font style="font-size: 90.0%"><div class="tmweb-code">
          <pre class="verbatim cpp" xml:space="preserve">


  bracket (native, &quot;(&quot;, 1, 5, 3461, 22);
  bracket (native, &quot;)&quot;, 1, 5, 3462, 22);
  bracket (native, &quot;{&quot;, 1, 5, 3465, 22);
  bracket (native, &quot;}&quot;, 1, 5, 3466, 22);
  bracket (native, &quot;[&quot;, 1, 5, 3467, 22);
  bracket (native, &quot;]&quot;, 1, 5, 3468, 22);
  bracket (native, &quot;lceil&quot;, 1, 5, 3469, 22);
  bracket (native, &quot;rceil&quot;, 1, 5, 3470, 22);
  bracket (native, &quot;lfloor&quot;, 1, 5, 3471, 22);
  bracket (native, &quot;rfloor&quot;, 1, 5, 3472, 22);
  bracket (native, &quot;llbracket&quot;, 1, 5, 3473, 22);
  bracket (native, &quot;rrbracket&quot;, 1, 5, 3474, 22);
  bracket (native, &quot;langle&quot;, 1, 6, 3655, 4);
  bracket (native, &quot;rangle&quot;, 1, 6, 3656, 4);
  bracket (native, &quot;llangle&quot;, 1, 6, 3657, 4);
  bracket (native, &quot;rrangle&quot;, 1, 6, 3658, 4);
  bracket (native, &quot;/&quot;, 1, 6, 3742, 7);
  bracket (native, &quot;\\&quot;, 1, 6, 3743, 7);
  bracket (native, &quot;|&quot;, 1, 6, 3745, 7);
  bracket (native, &quot;||&quot;, 1, 6, 3746, 7);

  native (&quot;&lt;wide-hat-0&gt;&quot;)= 125;
  native (&quot;&lt;wide-tilde-0&gt;&quot;)= 126;
  native (&quot;&lt;wide-breve-0&gt;&quot;)= 128;
  native (&quot;&lt;wide-check-0&gt;&quot;)= 135;
  wide (native, &quot;breve&quot;, 1, 6, 3378, 10);
  wide (native, &quot;invbreve&quot;, 1, 6, 3380, 10);
  wide (native, &quot;check&quot;, 1, 6, 3382, 10);
  wide (native, &quot;hat&quot;, 1, 6, 3384, 10);
  wide (native, &quot;tilde&quot;, 1, 6, 3386, 10);
  wide (native, &quot;overbrace&quot;, 0, 5, 3453, 22);
  wide (native, &quot;overbrace*&quot;, 0, 5, 3453, 22);
  wide (native, &quot;underbrace&quot;, 0, 5, 3454, 22);
  wide (native, &quot;underbrace*&quot;, 0, 5, 3454, 22);
  wide (native, &quot;poverbrace&quot;, 0, 5, 3455, 22);
  wide (native, &quot;poverbrace*&quot;, 0, 5, 3455, 22);
  wide (native, &quot;punderbrace&quot;, 0, 5, 3456, 22);
  wide (native, &quot;punderbrace*&quot;, 0, 5, 3456, 22);
  wide (native, &quot;sqoverbrace&quot;, 0, 5, 3457, 22);
  wide (native, &quot;sqoverbrace*&quot;, 0, 5, 3457, 22);
  wide (native, &quot;squnderbrace&quot;, 0, 5, 3458, 22);
  wide (native, &quot;squnderbrace*&quot;, 0, 5, 3458, 22);
  return native;
}








</pre>
        </div></font></td>
      </tr></tbody>
    </table>
    <p>
      
    </p>
    <p>
      The dispatching function is 
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
unsigned int
unicode_font_rep::read_unicode_char (string s, int&amp; i) {
  if (s[i] == '&lt;') {
    i++;
    int start= i, n= N(s);
    while (true) {
      if (i == n) {
        i= start;
        return (int) '&lt;';
      }
      if (s[i] == '&gt;') break;
      i++;
    }
    if (s[start] == '#') {
      start++;
      return (unsigned int) from_hexadecimal (s (start, i++));
    }
    else {
      string ss= s (start-1, ++i);
      string uu= strict_cork_to_utf8 (ss);
      if (uu == ss) {
        if (native-&gt;contains (ss)) return 0xc000000 + native[ss];
        return 0;
      }
      int j= 0;
      return decode_from_utf8 (uu, j);
    }
  }
  else {
    unsigned int c= (unsigned int) s[i++];
    if (c &gt;= 32 &amp;&amp; c &lt;= 127) return c;
    string ss= s (i-1, i);
    string uu= strict_cork_to_utf8 (ss);
    int j= 0;
    return decode_from_utf8 (uu, j);
  }
}</pre>
    </div>
    <p>
      which maps entities of the form <tt class="verbatim">&lt;#XXXX&gt;</tt> in the
      Unicode code point <tt class="verbatim">XXXX</tt>, while tries to use the <tt
      class="verbatim cpp">strict_cork_to_utf8</tt> function to map other entities into a
      meaningful Unicode code point and if this fails check the <tt class="verbatim cpp">native</tt>
      lookup table for possible glyph indexes and return a &ldquo;fake&rdquo;
      unicode point of the form <tt class="verbatim cpp">0xc000000 + glyph_index</tt>. The
      function <tt class="verbatim cpp">decode_from_utf8</tt> converts <tt class="verbatim">UTF8</tt>
      into a <tt class="verbatim cpp">unsigned int</tt> Unicode point.
    </p>
    <p>
      This function is used by <tt class="verbatim cpp">supports</tt>:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
bool
unicode_font_rep::supports (string c) {
  if (N(c) == 0) return false;
  int i= 0;
  unsigned int uc= read_unicode_char (c, i);
  if (uc == 0 || !fnm-&gt;exists (uc)) return false;
  if (uc &gt;= 0x42 &amp;&amp; uc &lt;= 0x5a &amp;&amp; !fnm-&gt;exists (0x41)) return false;
  if (uc &gt;= 0x62 &amp;&amp; uc &lt;= 0x7a &amp;&amp; !fnm-&gt;exists (0x61)) return false;
  metric_struct* m= fnm-&gt;get (uc);
  return m-&gt;x1 &lt; m-&gt;x2 &amp;&amp; m-&gt;y1 &lt; m-&gt;y2;
}</pre>
    </div>
    <p>
      Note that <tt class="verbatim cpp">fnm-&gt;exists (uc)</tt> refers to
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
bool tt_font_metric_rep::exists (int i);</pre>
    </div>
    <p>
      which uses <tt class="verbatim cpp">decode_index</tt> to retrieve the glyph number
      (and decode the &ldquo;fake&rdquo; unicode points into direct glyph
      numbers)
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
inline FT_UInt
decode_index (FT_Face face, int i) {
  if (i &lt; 0xc000000) return ft_get_char_index (face, i);
  return i - 0xc000000;  
}</pre>
    </div>
    <p>
      Ligature replacement is implemented as follow
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
unsigned int
unicode_font_rep::ligature_replace (unsigned int uc, string s, int&amp; i) {
  int n= N(s);
  if (((char) uc) == 'f') {
    if (i&lt;n &amp;&amp; s[i] == 'i' &amp;&amp; (ligs &amp; LIGATURE_FI) != 0) {
      i++; return 0xfb01; }
    else if (i&lt;n &amp;&amp; s[i] == 'l' &amp;&amp; (ligs &amp; LIGATURE_FL) != 0) {
      i++; return 0xfb02; }
    else if (i&lt;n &amp;&amp; s[i] == 't' &amp;&amp; (ligs &amp; LIGATURE_FT) != 0) {
      i++; return 0xfb05; }
    else if ((i+1)&lt;n &amp;&amp; s[i] == 'f' &amp;&amp; s[i+1] == 'i' &amp;&amp;
             (ligs &amp; LIGATURE_FFI) != 0) {
      i+=2; return 0xfb03; }
    else if ((i+1)&lt;n &amp;&amp; s[i] == 'f' &amp;&amp; s[i+1] == 'l' &amp;&amp;
             (ligs &amp; LIGATURE_FFL) != 0) {
      i+=2; return 0xfb04; }
    else if (i&lt;n &amp;&amp; s[i] == 'f' &amp;&amp; (ligs &amp; LIGATURE_FF) != 0) {
      i++; return 0xfb00; }
    else return uc;
  }
  else if (((char) uc) == 's') {
    if (i&lt;n &amp;&amp; s[i] == 't' &amp;&amp; (ligs &amp; LIGATURE_ST) != 0) {
      i++; return 0xfb06; }
    else return uc;
  }
  else return uc;
}</pre>
    </div>
    <p>
      All these mechanisms works together in virtual methods like <tt class="verbatim cpp">draw_fixed</tt>
      to produce a series of glyphs on the rendering surface via the <tt
      class="verbatim cpp">draw</tt> method of <tt class="verbatim cpp">render_rep</tt>:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
void renderer_rep::draw (int c, font_glyphs fng, SI x, SI y)</pre>
    </div>
    <p>
      specifically the code of <tt class="verbatim cpp">unicode_font_rep::draw_fixed</tt>
      reads:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
void
unicode_font_rep::draw_fixed (renderer ren, string s, SI x, SI y, bool ligf) {
  int i= 0, n= N(s);
  unsigned int uc= 0xffffffff;
  while (i&lt;n) {
    unsigned int pc= uc;
    uc= read_unicode_char (s, i);
    if (ligs &gt; 0 &amp;&amp; ligf &amp;&amp; (((char) uc) == 'f' || ((char) uc) == 's'))
      uc= ligature_replace (uc, s, i);
    if (pc != 0xffffffff) x += ROUND (fnm-&gt;kerning (pc, uc));
    ren-&gt;draw (uc, fng, x, y);
    metric_struct* ex= fnm-&gt;get (uc);
    x += ROUND (ex-&gt;x2);
    //if (fnm-&gt;kerning (pc, uc) != 0)
    //cout &lt;&lt; &quot;Kerning &quot; &lt;&lt; ((char) pc) &lt;&lt; ((char) uc) &lt;&lt; &quot; &quot; &lt;&lt; ROUND (fnm-&gt;kerning (pc, uc)) &lt;&lt; &quot;, &quot; &lt;&lt; ROUND (ex-&gt;x2) &lt;&lt; &quot;\n&quot;;
  }
}</pre>
    </div>
    <h3 id="auto-20"><a id="sec:rubber-unicode"></a>8.3.<span style="margin-left: 1em"></span>Rubber Unicode fonts<span
    style="margin-left: 1em"></span></h3>
    <p>
      Rubber Unicode fonts are implemented similarly to rubber fonts. They
      dispatch according to the <tt class="verbatim cpp">search_font</tt> function which
      caches the subfont index and rewriting returned by <tt class="verbatim cpp">search_font_sub</tt>:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
int
rubber_unicode_font_rep::search_font_sub (string s, string&amp; rew) {
  if (starts (s, &quot;&lt;big-&quot;) &amp;&amp; ends (s, &quot;-1&gt;&quot;)) {
    string r= s (5, N(s) - 3);
    if (ends (r, &quot;lim&quot;)) r= r (0, N(r) - 3);
    if (starts (r, &quot;up&quot;)) r= r (2, N(r));
    r= &quot;&lt;&quot; * r * &quot;&gt;&quot;;
    if (base-&gt;supports (r)) {
      rew= r;
      if (r == &quot;&lt;sum&gt;&quot; || r == &quot;&lt;prod&gt;&quot; || ends (r, &quot;int&gt;&quot;))
        if (big_sums) return 0;
      return 2;
    }
  }
  if (starts (s, &quot;&lt;big-&quot;) &amp;&amp; ends (s, &quot;-2&gt;&quot;)) {
    if (big_flag &amp;&amp; base-&gt;supports (s)) {
      rew= s;
      return 0;
    }
    string r= s (5, N(s) - 3);
    if (ends (r, &quot;lim&quot;)) r= r (0, N(r) - 3);
    if (starts (r, &quot;up&quot;)) r= r (2, N(r));
    if (big_flag &amp;&amp; base-&gt;supports (&quot;&lt;big-&quot; * r * &quot;-1&gt;&quot;)) {
      rew= &quot;&lt;big-&quot; * r * &quot;-1&gt;&quot;;
      return 2;
    }
    r= &quot;&lt;&quot; * r * &quot;&gt;&quot;;
    if (base-&gt;supports (r)) {
      rew= r;
      if (r == &quot;&lt;sum&gt;&quot; || r == &quot;&lt;prod&gt;&quot; || ends (r, &quot;int&gt;&quot;))
        if (big_sums) return 2;
      return 3;
    }
  }
  if (starts (s, &quot;&lt;mid-&quot;)) s= &quot;&lt;left-&quot; * s (5, N(s));
  if (starts (s, &quot;&lt;right-&quot;)) s= &quot;&lt;left-&quot; * s (7, N(s));
  if (starts (s, &quot;&lt;large-&quot;)) s= &quot;&lt;left-&quot; * s (7, N(s));
  if (starts (s, &quot;&lt;left-&quot;)) {
    int pos= search_backwards (&quot;-&quot;, N(s), s);
    if (pos &gt; 6) {
      if (s[pos-1] == '-') pos--;
      string r= s (6, pos);
      if (r == &quot;.&quot;) { rew= &quot;&quot;; return 0; }
      if ((r == &quot;(&quot; &amp;&amp; base-&gt;supports (&quot;&lt;#239C&gt;&quot;)) ||
          (r == &quot;)&quot; &amp;&amp; base-&gt;supports (&quot;&lt;#239F&gt;&quot;)) ||
          (r == &quot;[&quot; &amp;&amp; base-&gt;supports (&quot;&lt;#23A2&gt;&quot;)) ||
          (r == &quot;]&quot; &amp;&amp; base-&gt;supports (&quot;&lt;#23A5&gt;&quot;)) ||
          ((r == &quot;{&quot; || r == &quot;}&quot;) &amp;&amp; base-&gt;supports (&quot;&lt;#23AA&gt;&quot;)) ||
          (r == &quot;sqrt&quot; &amp;&amp; base-&gt;supports (&quot;&lt;#23B7&gt;&quot;))) {
        rew= s;
        return 4;
      }
      rew= r;
      if (N(rew) &gt; 1) rew= &quot;&lt;&quot; * rew * &quot;&gt;&quot;;
      if (ends (s, &quot;-0&gt;&quot;)) return 0;
      return 0;
    }
  }
  rew= s;
  return 0;
}</pre>
    </div>
    <p>
      There are <tt class="verbatim cpp">5</tt> subfonts which are instantiated as follows:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
font
rubber_unicode_font_rep::get_font (int nr) {
  ASSERT (nr &lt; N(subfn), &quot;wrong font number&quot;);
  if (initialized[nr]) return subfn[nr];
  initialized[nr]= true;
  switch (nr) {
  case 0:
    break;
  case 1:
    subfn[nr]= base-&gt;magnify (sqrt (0.5));
    break;
  case 2:
    subfn[nr]= base-&gt;magnify (sqrt (2.0));
    break;
  case 3:
    subfn[nr]= base-&gt;magnify (2.0);
    break;
  case 4:
    subfn[nr]= rubber_assemble_font (base);
    break;
  }
  return subfn[nr];
}</pre>
    </div>
    <p>
      and are given by progressively zoomed versions of the base font plus an
      additional <tt class="verbatim cpp">rubber_assemble_font</tt> used to create synthetic
      rubber from pieces of the base Unicode font. Its implementation is
      relatively straighforward: for the first few sizes it uses magnified
      variants of the base font:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
#define MAGNIFIED_NUMBER 4
        
font
rubber_assemble_font_rep::get_font (int nr) {
  ASSERT (nr &lt; N(larger), &quot;wrong font number&quot;);
  if (initialized[nr]) return larger[nr];
  initialized[nr]= true;
  larger[nr]= base-&gt;magnify (pow (2.0, ((double) nr) / 4.0));
  return larger[nr];
}</pre>
    </div>
    <p>
      while for larger variants it uses the virtual glyphs described in the
      <tt class="verbatim cpp">&quot;emu-alt-large&quot;</tt> virtual font according to the
      following dispatching <tt class="verbatim cpp">search_font</tt> function:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
int
rubber_assemble_font_rep::search_font (string s, string&amp; r) {
  if (starts (s, &quot;&lt;mid-&quot;)) s= &quot;&lt;left-&quot; * s (5, N(s));
  if (starts (s, &quot;&lt;right-&quot;)) s= &quot;&lt;left-&quot; * s (7, N(s));
  if (starts (s, &quot;&lt;large-&quot;)) s= &quot;&lt;left-&quot; * s (7, N(s));
  if (starts (s, &quot;&lt;left-&quot;)) {
    int pos= search_backwards (&quot;-&quot;, N(s), s);
    if (pos &gt; 6) {
      if (s[pos-1] == '-') pos--;
      r= s (6, pos);
      int num= as_int (s (pos+1, N(s)-1));
      int nr= num - 5;
      int code;
      if (num &lt;= MAGNIFIED_NUMBER) return num;
      else if (r == &quot;(&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-lparenthesis-#&gt;&quot;];
      else if (r == &quot;)&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-rparenthesis-#&gt;&quot;];
      else if (r == &quot;[&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-lbracket-#&gt;&quot;];
      else if (r == &quot;]&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-rbracket-#&gt;&quot;];
      else if (r == &quot;{&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-lcurly-#&gt;&quot;];
      else if (r == &quot;}&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-rcurly-#&gt;&quot;];
      else if (r == &quot;lfloor&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-lfloor-#&gt;&quot;];
      else if (r == &quot;rfloor&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-rfloor-#&gt;&quot;];
      else if (r == &quot;lceil&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-lceil-#&gt;&quot;];
      else if (r == &quot;rceil&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-rceil-#&gt;&quot;];
      else if (r == &quot;.&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-nosymbol-#&gt;&quot;];
      else if (r == &quot;nosymbol&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-nosymbol-#&gt;&quot;];
      else if (r == &quot;|&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-bar-#&gt;&quot;];
      else if (r == &quot;||&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-parallel-#&gt;&quot;];
      else if (r == &quot;interleave&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-interleave-#&gt;&quot;];
      else if (r == &quot;sqrt&quot;)
        code= virt-&gt;dict [&quot;&lt;rubber-sqrt-#&gt;&quot;];
      else
        code= virt-&gt;dict [&quot;&lt;rubber-lparenthesis-#&gt;&quot;];
      r= string ((char) code) * as_string (nr) * &quot;&gt;&quot;;
      return MAGNIFIED_NUMBER + 1;
    }
  }
  r= s;
  return 0;
}</pre>
    </div>
    <h3 id="auto-21"><a id="sec:virtual-font"></a>8.4.<span style="margin-left: 1em"></span>Virtual fonts<span style="margin-left: 1em"></span></h3>
    <p>
      Virtual fonts provide a mechanism to extend the set of available glyphs
      by synthetizing new glyphs from operations on those of a base font. The
      programs which describe the sequence of (parametrized) operations to
      perform are formulated in a domain-specific language of s-expressions. 
    </p>
    <p>
      The main entry point is the function
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
font virtual_font (font base, string name, int size, int hdpi, int vdpi, bool extend);</pre>
    </div>
    <p>
      The <tt class="verbatim cpp">extend</tt> flag allows to control if the virtual font
      behaves as an overlay over the base font allowing to access the
      base-defined glyphs or not.
    </p>
    <p>
      Virtual fonts definitions are collected in the <tt class="verbatim">$TEXMACS_PATH/fonts/virtual</tt>
      directory with suffix <tt class="verbatim">.vfn</tt>. As an example of the DSL,
      here the <tt class="verbatim">emu-bracket.vfn</tt> font which describes the
      synthetic large brackets:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim" xml:space="preserve">
(virtual-font
  (emu-backslash (hor-flip /))
  (emu-tslash (unindent (crop (part (crop /) * * 0.5 *))))
  (emu-tbackslash (hor-flip emu-tslash))
  (emu-bslash (unindent (crop (part (crop /) * * * 0.5))))
  (emu-bbackslash (hor-flip emu-bslash))
  (emu-langle-pre (unindent (join (unindent emu-bbackslash)
                                  (unindent emu-tslash))))
  (emu-rangle-pre (unindent (join (unindent* emu-bslash)
                                  (unindent* emu-tbackslash))))
  (emu-langle-bis (with sc (/ (height (crop [)) (height emu-langle-pre))
                    (align* (magnify emu-langle-pre * sc) [ * 0.5)))
  (emu-rangle-bis (with sc (/ (height (crop ])) (height emu-rangle-pre))
                    (align* (magnify emu-rangle-pre * sc) ] * 0.5)))
  (emu-langle (unindent (enlarge emu-langle-bis 0.1 0.1 0 0)))
  (emu-rangle (unindent (enlarge emu-rangle-bis 0.1 0.1 0 0)))
  (emu-llangle (join (0 0 emu-langle) (0.2 0 emu-langle)))
  (emu-rrangle (join (0 0 emu-rangle) (0.2 0 emu-rangle)))
  (emu-lfloor (join (part [ * * * 0.5) (part [ * * 0.25 0.75 0  0.25)))
  (emu-rfloor (join (part ] * * * 0.5) (part ] * * 0.25 0.75 0  0.25)))
  (emu-lceil  (join (part [ * * 0.5 *) (part [ * * 0.25 0.75 0 -0.25)))
  (emu-rceil  (join (part ] * * 0.5 *) (part ] * * 0.25 0.75 0 -0.25)))
  (emu-dlbracket (glue [ [))
  (emu-drbracket (glue ] ]))
  (emu-dlfloor (join (part emu-dlbracket * * * 0.5)
                     (part emu-dlbracket * * 0.25 0.75 0  0.25)))
  (emu-drfloor (join (part emu-drbracket * * * 0.5)
                     (part emu-drbracket * * 0.25 0.75 0  0.25)))
  (emu-dlceil  (join (part emu-dlbracket * * 0.5 *)
                     (part emu-dlbracket * * 0.25 0.75 0 -0.25)))
  (emu-drceil  (join (part emu-drbracket * * 0.5 *)
                     (part emu-drbracket * * 0.25 0.75 0 -0.25)))
  (emu-tlbracket (glue [ emu-dlbracket))
  (emu-trbracket (glue ] emu-drbracket))
  (emu-tlfloor (join (part emu-tlbracket * * * 0.5)
                     (part emu-tlbracket * * 0.25 0.75 0  0.25)))
  (emu-trfloor (join (part emu-trbracket * * * 0.5)
                     (part emu-trbracket * * 0.25 0.75 0  0.25)))
  (emu-tlceil  (join (part emu-tlbracket * * 0.5 *)
                     (part emu-tlbracket * * 0.25 0.75 0 -0.25)))
  (emu-trceil  (join (part emu-trbracket * * 0.5 *)
                     (part emu-trbracket * * 0.25 0.75 0 -0.25)))
  (emu-dbar (join #7C (part #7C * * * * 0.6 0)))
  (emu-tbar (join #7C (part #7C * * * * 0.6 0)
                      (part #7C * * * * 1.2 0))))</pre>
    </div>
    <p>
      As we see the file is composed by a single S-expression with head <tt
      class="verbatim">virtual-font</tt> and a sequence of glyph definitions in the form
      <tt class="verbatim">(glyph-name glyph-code)</tt>. The code itself is composed
      recursively by operators with arguments given by further subexpressions.
    </p>
    <p>
      One of the interpreters of the language is <tt class="verbatim cpp">draw_tree</tt>:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
void virtual_font_rep::draw_tree (renderer ren, scheme_tree t, SI x, SI y);</pre>
    </div>
    <p>
      The code expressions are evaluated as follows. We indicate with a
      dollar-prefixed label like <tt class="verbatim">$val</tt> variables which match
      subexpressions in the templates.
    </p>
    <p>
      An atomic value (not a list) refers to a glyph in the base font or to
      another virtual glyph. 
    </p>
    <p>
      A list of the form <tt class="verbatim">($x $y $s)</tt> where <tt class="verbatim">$x</tt>,
      <tt class="verbatim">$y</tt> are floating-point numbers and <tt class="verbatim">$s</tt> a
      symbol, evaluate in the glyph associated to <tt class="verbatim">$s</tt> and
      shifted according to the pair <tt class="verbatim">$x</tt>, <tt class="verbatim">$y</tt>.
    </p>
    <p>
      <tt class="verbatim">(with $var $val $body)</tt> evaluates <tt class="verbatim">$body</tt>
      with the symbol <tt class="verbatim">$var</tt> replaced by the value of the
      expression <tt class="verbatim">$val</tt>. 
    </p>
    <p>
      <tt class="verbatim">(or $el1 $el2 <span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span
      style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>)</tt> evaluates in the first valid
      expression in the list (as determined by the <tt class="verbatim cpp">supported</tt>
      method)
    </p>
    <p>
      <tt class="verbatim">(join $el1 $el2 <span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span
      style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>)</tt> evaluates in the superposition
      of the result of all the expressions, in sequence, in the list;
    </p>
    <p>
      <tt class="verbatim">(intersect $glyph1 $glyph2)</tt>, <tt class="verbatim">(exclude $glyph1
      $glyph2)</tt> compose glyph bitmaps with raster operators
    </p>
    <p>
      <tt class="verbatim">(bitmap $glyph)</tt> evaluates in the result of <tt class="verbatim">$s</tt>;
    </p>
    <p>
      <tt class="verbatim">(glue $glyph1 $glyph2)</tt>, <tt class="verbatim">(glue* $glyph1
      $glyph2)</tt> glue virtual glyphs horizontally with different
      alignements
    </p>
    <p>
      <tt class="verbatim">(glue-above $glyph1 $glyph2 $dy)</tt>, <tt class="verbatim">(glue-below
      $glyph1 $glyph2 $dy)</tt> glue glyphs vertically with an optional shift
    </p>
    <p>
      In the following we list most of the other available operators, for
      details on their meaning please refer to the source code of <tt class="verbatim">virtual_font_rep</tt>.
    </p>
    <pre class="verbatim" xml:space="preserve">
(row $e1 $e2)</pre>
    <p>
      <tt class="verbatim">(stack $glyph1 $glyph2 $e3)</tt>, <tt class="verbatim">(stack-equal
      $glyph1 $glyph2 $e3)</tt>, <tt class="verbatim">(stack-less $glyph1 $glyph2
      $e3)</tt>
    </p>
    <p>
      <tt class="verbatim">(right-fit $glyph1 $glyph2 $e3)</tt>, <tt class="verbatim">(left-fit
      $glyph1 $glyph2 $e3)</tt>
    </p>
    <pre class="verbatim" xml:space="preserve">
(add $glyph1 $glyph2)</pre>
    <pre class="verbatim" xml:space="preserve">
(magnify $e1 $e2 $e3)</pre>
    <pre class="verbatim" xml:space="preserve">
(enlarge $e1)</pre>
    <p>
      <tt class="verbatim">(unindent $e1)</tt>, <tt class="verbatim">(unindent* $e1)</tt>
    </p>
    <p>
      <tt class="verbatim">(crop $e1)</tt>, <tt class="verbatim">(hor-crop $e1)</tt>, <tt class="verbatim">(ver-crop
      $e1)</tt>, <tt class="verbatim">(left-crop $e1)</tt>,<tt class="verbatim">(right-crop
      $e1)</tt>, <tt class="verbatim">(top-crop $e1)</tt>, <tt class="verbatim">(bottom-crop
      $e1)</tt>
    </p>
    <pre class="verbatim" xml:space="preserve">
(clip $glyph $x1 $y1 $x2 $y2)</pre>
    <pre class="verbatim" xml:space="preserve">
(part $glyph $x1 $y1 $x2 $y2 $dx $dy)</pre>
    <pre class="verbatim" xml:space="preserve">
(copy $e1)</pre>
    <p>
      <tt class="verbatim">(hor-flip $e1)</tt>, <tt class="verbatim">(ver-flip $e1)</tt>, <tt
      class="verbatim">(rot-left $e1)</tt>, <tt class="verbatim">(rot-right $e1)</tt>
    </p>
    <pre class="verbatim" xml:space="preserve">
(rotate $glyph $angle $xf $yf)</pre>
    <p>
      <tt class="verbatim">(hor-extend $glyph $xx $yy $zz)</tt>, <tt class="verbatim">(ver-extend
      $glyph $xx $yy $zz)</tt>
    </p>
    <pre class="verbatim" xml:space="preserve">
(ver-take $glyph $xx $yy $zz)</pre>
    <p>
      <tt class="verbatim">(align $glyph $xx $yy)</tt>, <tt class="verbatim">(align* $glyph $xx
      $yy)</tt>
    </p>
    <p>
      <tt class="verbatim">(scale $glyph1 $glyph2 $sx $sy)</tt>, <tt class="verbatim">(scale*
      $glyph1 $glyph2 $sx $sy)</tt>
    </p>
    <pre class="verbatim" xml:space="preserve">
(hor-scale $glyph1 $glyph2)</pre>
    <p>
      <tt class="verbatim">(pretend $glyph1 $glyph2)</tt>, <tt class="verbatim">(hor-pretend
      $glyph1 $glyph2)</tt>, <tt class="verbatim">(left-pretend $glyph1 $glyph2)</tt>,
      <tt class="verbatim">(right-pretend $glyph1 $glyph2)</tt>, <tt class="verbatim">(ver-pretend
      $glyph1 $glyph2)</tt>
    </p>
    <pre class="verbatim" xml:space="preserve">
(relash $glyph1 $glyph2)</pre>
    <pre class="verbatim" xml:space="preserve">
(negate $glyph1 $glyph2)</pre>
    <p>
      <tt class="verbatim">(min-width $glyph1 $glyph2)</tt>, <tt class="verbatim">(max-width
      $glyph1 $glyph2)</tt>, <tt class="verbatim">(min-height $glyph1 $glyph2)</tt>, <tt
      class="verbatim">(max-height $glyph1 $glyph2)</tt>
    </p>
    <pre class="verbatim" xml:space="preserve">
(font $p1 $p2 $p3 &hellip;)</pre>
    <pre class="verbatim" xml:space="preserve">
(italic $p1 $p2 $p3)</pre>
    <pre class="verbatim" xml:space="preserve">
(circle $r $w)</pre>
    <h3 id="auto-22">8.5.<span style="margin-left: 1em"></span>TeX fonts<span style="margin-left: 1em"></span></h3>
    <p>
      TeX fonts are physical fonts are handled via specific mechanisms which
      decoded the TeX font files and metrrics to produce metric informations
      for the typesetter and bitmaps for the renderer. They work similarly to
      Unicode fonts, but the specifics of the encoding of the various TeXmacs
      entities is complex due to the limitations in the design of the font
      files and a logical font must be reconstructed gluing together several
      physical fonts and taking care of rubber, mathematical alphabeths,
      etc<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span
      style="margin-left: 0.16665em"></span>
    </p>
    <h3 id="auto-23">8.6.<span style="margin-left: 1em"></span>Compound fonts for mathematics<span style="margin-left: 1em"></span></h3>
    <p>
      The <tt class="verbatim cpp">math_font</tt> class represent a compound font which can
      render all the usual entities for mathematical document preparation. It
      is modelled around TeX math fonts to map several physical fonts to cover
      all math alphabets. 
    </p>
    <h2 id="auto-24">9.<span style="margin-left: 1em"></span>From logical to physical font<span style="margin-left: 1em"></span></h2>
    <p>
      As we already discusses, TeXmacs implements a font substitution
      mechanism that tries to find a physical font which better fits a given
      series of characteristics. This is used to find replacements for missing
      features (like a bold alphabeth, or upright Greek letters, etc<span
      style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>)
      or glyph sets (e.g. Greek, Cyrillic, asian fonts, mathematical letters,
      mathematical symbols)
    </p>
    <p>
      The entrypoint of this system is the function
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
font closest_font (string family, string variant, string series, string shape,
                 int sz, int dpi, int attempt)</pre>
    </div>
    <p>
      which returns a physical font which fits certain characteristics (i.e.
      family, variant, series, shape). The <tt class="verbatim cpp">attempt</tt> variable is
      used to iterate amont the possibile return values according to the order
      given by a distance function defined among all fonts. The function <tt
      class="verbatim cpp">closest_font</tt> calls <tt class="verbatim cpp">find_closest</tt> to do
      caching and the actual search of a physical font with suitable
      characteristics:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
bool
find_closest (string&amp; family, string&amp; variant, string&amp; series, string&amp; shape,
              int attempt) {
  static hashmap&lt;tree,tree&gt; closest_cache (UNINIT);
  tree val= tuple (copy (family), variant, series, shape);
  tree key= tuple (copy (family), variant, series, shape, as_string (attempt));
  if (closest_cache-&gt;contains (key)) {
    tree t = closest_cache[key];
    family = t[0]-&gt;label;
    variant= t[1]-&gt;label;
    series = t[2]-&gt;label;
    shape  = t[3]-&gt;label;
    return t != val;
  }
  else {
    //cout &lt;&lt; &quot;&lt; &quot; &lt;&lt; family &lt;&lt; &quot;, &quot; &lt;&lt; variant
    //     &lt;&lt; &quot;, &quot; &lt;&lt; series &lt;&lt; &quot;, &quot; &lt;&lt; shape &lt;&lt; &quot;\n&quot;;
    array&lt;string&gt; lfn= logical_font (family, variant, series, shape);
    lfn= apply_substitutions (lfn);
    array&lt;string&gt; pfn= search_font (lfn, attempt);
    array&lt;string&gt; nfn= logical_font (pfn[0], pfn[1]);
    array&lt;string&gt; gfn= guessed_features (pfn[0], pfn[1]);
    //cout &lt;&lt; lfn &lt;&lt; &quot; -&gt; &quot; &lt;&lt; pfn &lt;&lt; &quot;, &quot; &lt;&lt; nfn &lt;&lt; &quot;, &quot; &lt;&lt; gfn &lt;&lt; &quot;\n&quot;;
    gfn &lt;&lt; nfn;
    family= get_family (nfn);
    variant= get_variant (nfn);
    series= get_series (nfn);
    shape= get_shape (nfn);
    if ( contains (string (&quot;outline&quot;), lfn) &amp;&amp;
        !contains (string (&quot;outline&quot;), gfn))
      variant= variant * &quot;-poorbbb&quot;;
    if ( contains (string (&quot;bold&quot;), lfn) &amp;&amp;
        !contains (string (&quot;bold&quot;), gfn))
      series= series * &quot;-poorbf&quot;;
    if ( contains (string (&quot;smallcaps&quot;), lfn) &amp;&amp;
        !contains (string (&quot;smallcaps&quot;), gfn))
      shape= shape * &quot;-poorsc&quot;;
    if ((contains (string (&quot;italic&quot;), lfn) ||
         contains (string (&quot;oblique&quot;), lfn)) &amp;&amp;
        !contains (string (&quot;italic&quot;), gfn) &amp;&amp;
        !contains (string (&quot;oblique&quot;), gfn))
      shape= shape * &quot;-poorit&quot;;
    //cout &lt;&lt; &quot;&gt; &quot; &lt;&lt; family &lt;&lt; &quot;, &quot; &lt;&lt; variant
    //     &lt;&lt; &quot;, &quot; &lt;&lt; series &lt;&lt; &quot;, &quot; &lt;&lt; shape &lt;&lt; &quot;\n&quot;;
    tree t= tuple (family, variant, series, shape);
    closest_cache (key)= t;
    return t != val;
  }
}</pre>
    </div>
    <p>
      As we see, this function uses <tt class="verbatim cpp">search_font</tt> to determine
      available fonts with similar characteristics (as specified by <tt class="verbatim cpp">logical_font</tt>
      and after performing some substitutions via <tt class="verbatim cpp">apply_substitutions</tt>).
      If the selected font does not posses features (outline, bold, smallcaps,
      italic) of the required font, we synthetize them via &ldquo;poor&rdquo;
      replacements. 
    </p>
    <p>
      Font substitutions are collected in the file <tt class="verbatim">$TEXMACS_PATH/fonts/font-substitutions.scm</tt>
      whose format is a list of Scheme expressions like
    </p>
    <div class="tmweb-code">
      <pre class="verbatim" xml:space="preserve">

((Bodoni\ 72 smallcaps) (Bodoni\ 72\ Smallcaps))
((Bodoni\ 72\ Oldstyle smallcaps) (Bodoni\ 72\ Smallcaps))
((Linux\ Libertine sansserif) (Linux\ Biolinum))
((TeX\ Gyre\ Pagella typewriter) (roman typewriter))

((Calibri typewriter) (Consolas))
((Cambria sansserif) (Calibri))
((Cambria typewriter) (Consolas))
((Constantia sansserif) (Corbel))
((Constantia typewriter) (Consolas))
((Corbel typewriter) (Consolas))
</pre>
    </div>
    <p>
      which specify replacement families for a given combination of family and
      feature of a logical font. For example the correct <tt class="verbatim">sansserif</tt>
      version of <tt class="verbatim">Linux Libertine</tt> is <tt class="verbatim">Linux
      Biolinum</tt>, etc<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span
      style="margin-left: 0.16665em"></span>
    </p>
    <p>
      The other important configuration files which control the selection of
      physical fonts are <tt class="verbatim">font-features.scm</tt>, <tt class="verbatim">font-database.scm</tt>
      and <tt class="verbatim">font-characteristics.scm</tt> all located in the folder
      <tt class="verbatim">$TEXMACS_PATH/fonts</tt>. These are computer generated and
      cache several important informations obtained by analyzing the available
      font files, those local to the specific installation of TeXmacs are kept
      in <tt class="verbatim">$TEXMACS_HOME_PATH/fonts</tt>. 
    </p>
    <p>
      The file <tt class="verbatim">font-database.scm</tt> associate to each font
      identifier a the filename and a subfont number:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim" xml:space="preserve">
((TeXmacs\ Computer\ Modern\ Sans Bold) ((ecsx10.tfm 0 3132)))
((TeXmacs\ Computer\ Modern\ Sans Bold\ Condensed) ((ecssdc10.tfm 0 3128)))
((TeXmacs\ Computer\ Modern\ Sans Bold\ Flat) ((eclb10.tfm 0 3584)))
((TeXmacs\ Computer\ Modern\ Sans Bold\ Italic\ Flat) ((eclo10.tfm 0 3584)))
((TeXmacs\ Computer\ Modern\ Sans Bold\ Oblique) ((ecso10.tfm 0 3352)))
((TeXmacs\ Computer\ Modern\ Sans Flat) ((eclq10.tfm 0 3584)))
((TeXmacs\ Computer\ Modern\ Sans Italic\ Flat) ((ecli10.tfm 0 3584)))
((TeXmacs\ Computer\ Modern\ Sans Oblique) ((ecsi10.tfm 0 3360)))
((TeXmacs\ Computer\ Modern\ Sans Regular) ((ecss10.tfm 0 3140)))
((TeXmacs\ Concrete Bold) ((ecbx10.tfm 0 3200)))
((TeXmacs\ Concrete Bold\ Condensed) ((ecrb10.tfm 0 3196)))
((TeXmacs\ Concrete Bold\ Italic) ((ecbi10.tfm 0 2900)))
((TeXmacs\ Concrete Bold\ Oblique) ((ecbl10.tfm 0 3412)))</pre>
    </div>
    <p>
      The file <tt class="verbatim"><tt class="verbatim">font-features.scm</tt></tt> records the
      available features for each font identifier, for example: 
    </p>
    <div class="tmweb-code">
      <pre class="verbatim" xml:space="preserve">
(Tangerine Tangerine Italic ArtPen Calligraphic)
(Telugu\ MN Telugu\ MN)
(Telugu\ Sangam\ MN Telugu\ Sangam\ MN SansSerif)
(Tempora Tempora)
(TeX\ AMS\ Blackboard\ Bold Bbb Outline)
(TeX\ Bard bard Ancient)
(TeX\ Blackboard\ Bold Bbb* Outline)
(TeX\ Blackboard\ Bold\ Sans Bbb* SansSerif Outline)
(TeX\ Blackboard\ Bold\ Variant Bbb** Outline)
(TeX\ Blackletter blackletter Ancient Gothic)
(TeX\ Calligraphic calligraphic Italic ArtPen Attached Calligraphic)
(TeX\ Calligraphic\ Capitals cal Calligraphic)</pre>
    </div>
    <p>
      While the <tt class="verbatim">font-characteristics.scm</tt> file records several
      attributes associated to each font, which are used to determine
      similar-looking fonts and their relative distance:
    </p>
    <div class="tmweb-code">
      <pre class="verbatim" xml:space="preserve">
((TeX\ Gothic Regular) (mono=no sans=no slant=17 italic=no case=mixed regular=no ex=83 em=187 lvw=27 lhw=19 uvw=15 uhw=144 fillp=40 vcnt=47 lasprat=66 pasprat=65 loasc=134 lodes=139 dides=104))
((TeX\ Gyre\ Adventor Bold) (Ascii Latin Greek mono=no sans=yes slant=0 italic=no case=mixed regular=yes ex=92 em=163 lvw=23 lhw=21 uvw=25 uhw=23 fillp=56 vcnt=62 lasprat=99 pasprat=85 loasc=139 lodes=140 dides=102))
((TeX\ Gyre\ Adventor Bold\ Italic) (Ascii Latin Greek mono=no sans=yes slant=18 italic=no case=mixed regular=yes ex=92 em=163 lvw=23 lhw=21 uvw=23 uhw=23 fillp=48 vcnt=56 lasprat=99 pasprat=97 loasc=139 lodes=140 dides=102))
((TeX\ Gyre\ Adventor Italic) (Ascii Latin Greek mono=no sans=yes slant=20 italic=no case=mixed regular=yes ex=91 em=168 lvw=14 lhw=12 uvw=14 uhw=12 fillp=30 vcnt=35 lasprat=99 pasprat=95 loasc=135 lodes=139 dides=102))
((TeX\ Gyre\ Adventor Regular) (Ascii Latin Greek mono=no sans=yes slant=0 italic=no case=mixed regular=yes ex=91 em=168 lvw=13 lhw=12 uvw=13 uhw=12 fillp=36 vcnt=38 lasprat=99 pasprat=83 loasc=135 lodes=139 dides=102))
((TeX\ Gyre\ Bonum Bold) (Ascii Latin Greek mono=no sans=no slant=0 italic=no case=mixed regular=yes ex=84 em=186 lvw=35 lhw=19 uvw=38 uhw=20 fillp=55 vcnt=60 lasprat=115 pasprat=110 loasc=152 lodes=148 dides=102))</pre>
    </div>
    <p>
      
    </p>
    <p>
      An alternative font selection mechanism, active in particular when <tt
      class="verbatim cpp">new_fonts</tt> is <tt class="verbatim cpp">false</tt>, is a macro-based
      font-selection scheme (using the <class style="font-variant: small-caps">Scheme</class> syntax),
      which allows the user to decide which parameters should be considered
      meaningful. At the lowest level, TeXmacs provides a fixed number of
      macros which directly correspond to the above types of concrete fonts.
      For instance, the macro 
    </p>
    <pre class="verbatim scheme" xml:space="preserve">
    (tex $name $size $dpi)</pre>
    <p>
      corresponds to the constructor
    </p>
    <div class="tmweb-code">
      <pre class="verbatim cpp" xml:space="preserve">
font tex_font (display dis, string fam, int size, int dpi, int dsize=10);</pre>
    </div>
    <p>
      of a TeX text font. 
    </p>
    <p>
      At the middle level, it is possible to specify some rewriting rules like
      
    </p>
    <div class="tmweb-code">
      <pre class="verbatim scheme" xml:space="preserve">
((roman rm medium right $s $d) (ec ecrm $s $d))
((avant-garde rm medium right $s $d) (tex rpagk $s $d 0))
((x-times rm medium right $s $d) (ps adobe-times-medium-r-normal $s $d))</pre>
    </div>
    <p>
      When a left hand pattern is matched, it is recursively substituted by
      the right hand side. The files in the directory <tt class="verbatim">progs/fonts</tt>
      contain a large number of rewriting rules.
    </p>
    <p>
      At the top level, TeXmacs calls (via the <tt class="verbatim cpp">find_font</tt>
      function) a macro of the form 
    </p>
    <div class="tmweb-code">
      <pre class="verbatim scheme" xml:space="preserve">
($name $family $series $shape $size $dpi)</pre>
    </div>
    <p>
      as a function of the current environment in the text.
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
  </body>
</html>